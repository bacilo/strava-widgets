---
phase: 11-route-map-widgets
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/compute-route-data.mjs
  - src/widgets/shared/route-utils.ts
  - scripts/build-widgets.mjs
  - package.json
autonomous: true
requirements: [ROUTE-04, ROUTE-05]

must_haves:
  truths:
    - "Route data JSON files exist with correct structure for all activities with polylines"
    - "Shared route utilities decode polylines, auto-fit maps, and format popups"
    - "npm run compute-route-data generates data/routes/ files from activity data"
  artifacts:
    - path: "scripts/compute-route-data.mjs"
      provides: "Route data generation script"
      min_lines: 40
    - path: "src/widgets/shared/route-utils.ts"
      provides: "Shared RouteRenderer utility with polyline decode, fitBounds, popup formatting"
      exports: ["RouteRenderer", "RouteData"]
      min_lines: 60
    - path: "data/routes/route-list.json"
      provides: "All activities with metadata and polylines for widget consumption"
    - path: "data/routes/latest-runs.json"
      provides: "Latest 20 activities with polylines for overlay widget"
  key_links:
    - from: "scripts/compute-route-data.mjs"
      to: "data/activities/*.json"
      via: "reads activity files, extracts route data"
      pattern: "readdirSync.*activities"
    - from: "src/widgets/shared/route-utils.ts"
      to: "leaflet"
      via: "L.polyline, fitBounds, bindPopup"
      pattern: "L\\.polyline|fitBounds|bindPopup"
---

<objective>
Pre-compute route data files and create shared route rendering utilities for all Phase 11 map widgets.

Purpose: Route widgets need optimized data (not 7.1MB raw activities) and a shared RouteRenderer utility to avoid duplicating polyline decode, auto-fit, and popup logic across three widgets.

Output:
- `scripts/compute-route-data.mjs` — generates `data/routes/route-list.json` and `data/routes/latest-runs.json`
- `src/widgets/shared/route-utils.ts` — RouteRenderer class with renderRoute(), renderMultipleRoutes(), calculatePace()
- Updated `package.json` with `compute-route-data` npm script
- Updated `scripts/build-widgets.mjs` to copy `data/routes/` into dist
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-route-map-widgets/11-RESEARCH.md
@.planning/phases/10-geocoding-foundation-map-infrastructure/10-02-SUMMARY.md
@.planning/phases/10-geocoding-foundation-map-infrastructure/10-03-SUMMARY.md
@scripts/build-widgets.mjs
@src/widgets/shared/widget-base.ts
@src/geo/polyline-decoder.ts
@src/types/strava.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create route data pre-computation script and generate data files</name>
  <files>scripts/compute-route-data.mjs, data/routes/route-list.json, data/routes/latest-runs.json, package.json, scripts/build-widgets.mjs</files>
  <action>
Create `scripts/compute-route-data.mjs` that:
1. Reads all JSON files from `data/activities/`
2. For each activity, extracts: id, name, start_date_local, distance (meters), moving_time (seconds), map.summary_polyline, start_latlng
3. Filters out activities without summary_polyline (treadmill/manual entries)
4. Sorts by start_date_local descending (newest first)
5. Writes `data/routes/route-list.json` with ALL activities that have polylines. Each entry has: `{ id, name, date, distance, movingTime, polyline, startLat, startLng }`
6. Writes `data/routes/latest-runs.json` with the 20 most recent activities (same structure)
7. Logs summary: total activities, activities with routes, output file sizes

Use plain Node.js (fs, path) — no external dependencies needed. Create `data/routes/` directory if it doesn't exist (mkdirSync with recursive).

Add npm script to package.json:
```json
"compute-route-data": "node scripts/compute-route-data.mjs"
```

Update `scripts/build-widgets.mjs` `copyDataFiles()` function to also copy `data/routes/` to `dist/widgets/data/routes/`:
```javascript
{ src: 'data/routes', dest: 'dist/widgets/data/routes' }
```

Run the script to generate the actual data files. Verify route-list.json has entries and latest-runs.json has exactly 20 entries (or fewer if less than 20 activities have polylines).
  </action>
  <verify>
Run: `node scripts/compute-route-data.mjs`
Verify output:
- `data/routes/route-list.json` exists and contains array of objects with id, name, date, distance, movingTime, polyline, startLat, startLng
- `data/routes/latest-runs.json` exists and contains <= 20 entries
- `npm run compute-route-data` succeeds
- `node scripts/build-widgets.mjs` succeeds (build still works)
  </verify>
  <done>Route data files generated from activity data, npm script registered, build system copies route data to dist</done>
</task>

<task type="auto">
  <name>Task 2: Create shared RouteRenderer utility with polyline decode, auto-fit, and popup formatting</name>
  <files>src/widgets/shared/route-utils.ts</files>
  <action>
Create `src/widgets/shared/route-utils.ts` with:

1. **RouteData interface** (exported):
```typescript
export interface RouteData {
  id: number;
  name: string;
  date: string;
  distance: number;      // meters
  movingTime: number;     // seconds
  polyline: string;       // encoded polyline
  startLat: number;
  startLng: number;
}
```

2. **RouteRenderOptions interface** (exported):
```typescript
export interface RouteRenderOptions {
  color?: string;         // default '#fc4c02' (Strava orange)
  weight?: number;        // default 3
  opacity?: number;       // default 0.8
  showPopup?: boolean;    // default true
  fitBounds?: boolean;    // default true
}
```

3. **RouteRenderer class** (exported) with static methods:

- `renderRoute(map: L.Map, route: RouteData, options?: RouteRenderOptions): L.Polyline` — Decodes route.polyline using @mapbox/polyline, creates L.polyline with styling, optionally auto-fits bounds (with fallback for single-point routes: check bounds.isValid(), use [route.startLat, route.startLng] with zoom 13 if invalid), optionally binds popup with formatted metadata. Returns the polyline for cleanup.

- `renderMultipleRoutes(map: L.Map, routes: RouteData[], options?: RouteRenderOptions): L.Polyline[]` — Renders each route with distinct color via HSL hue rotation (index * 360 / routes.length), fits map to combined bounds using L.featureGroup(polylines).getBounds(). Returns array of polylines for cleanup.

- `formatPopupContent(route: RouteData): string` — Returns HTML string: route name (bold), distance in km (1 decimal), formatted date (e.g., "Oct 14, 2023"), pace in min:sec/km format. Use inline styles (popup content is plain HTML outside Shadow DOM).

- `calculatePace(distanceMeters: number, movingTimeSec: number): string` — Returns pace as "M:SS/km" format. Handle edge case of zero distance (return "--:--/km").

- `addHoverEffect(polyline: L.Polyline, normalWeight?: number, hoverWeight?: number): void` — Adds mouseover (weight+2, opacity 1.0) and mouseout (reset) event listeners.

Import Leaflet as `import L from 'leaflet'` and polyline as `import polylineCodec from '@mapbox/polyline'`. Auto-fit uses padding: [20, 20] and maxZoom: 15 to prevent over-zooming.
  </action>
  <verify>
Run: `npx tsc --noEmit` — TypeScript compiles without errors.
Verify route-utils.ts exports RouteRenderer, RouteData, RouteRenderOptions.
  </verify>
  <done>Shared RouteRenderer utility provides polyline decoding, auto-fit with fallback, popup formatting, hover effects, and multi-route color distribution — ready for consumption by all three route widgets</done>
</task>

</tasks>

<verification>
1. `npm run compute-route-data` generates data/routes/route-list.json and data/routes/latest-runs.json
2. `npx tsc --noEmit` passes (route-utils.ts compiles)
3. `npm run build-widgets` succeeds (build system copies route data)
4. route-list.json entries have all required fields (id, name, date, distance, movingTime, polyline, startLat, startLng)
5. latest-runs.json has <= 20 entries sorted by date descending
</verification>

<success_criteria>
- Route data files generated from 1,808 activities (filtering to those with polylines)
- RouteRenderer class provides renderRoute, renderMultipleRoutes, formatPopupContent, calculatePace, addHoverEffect
- Auto-fit handles both normal routes (fitBounds) and single-point routes (setView fallback)
- Build system deploys route data alongside widget bundles
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-route-map-widgets/11-01-SUMMARY.md`
</output>
