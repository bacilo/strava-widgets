---
phase: 13-standalone-pages
plan: 02
type: execute
wave: 1
depends_on: ["13-01"]
files_modified:
  - src/widgets/shared/widget-base.ts
  - src/widgets/heatmap-widget/index.ts
  - src/widgets/pin-map-widget/index.ts
  - src/widgets/route-browser/index.ts
  - src/widgets/single-run-map/index.ts
  - src/widgets/multi-run-overlay/index.ts
  - src/widgets/map-test-widget/index.ts
  - src/pages/heatmap.html
  - src/pages/pinmap.html
  - src/pages/routes.html
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Opening heatmap.html shows a full-viewport interactive heatmap with contiguous tiles filling 100% of the browser window"
    - "Opening pinmap.html shows a full-viewport pin map with visible pins and contiguous tiles filling 100% of the browser window"
    - "Opening routes.html shows a full-viewport route browser with sidebar and contiguous map tiles filling 100% of the browser window"
    - "Leaflet zoom/pan controls work correctly on all three standalone pages"
    - "Embedded widgets on index.html continue to render correctly at their default heights (not broken by these changes)"
  artifacts:
    - path: "src/widgets/shared/widget-base.ts"
      provides: "data-height in observedAttributes and applied as height on :host"
      contains: "data-height"
    - path: "src/widgets/heatmap-widget/index.ts"
      provides: "Leaflet CSS injected into Shadow DOM"
      contains: "leaflet.css?inline"
    - path: "src/widgets/pin-map-widget/index.ts"
      provides: "Leaflet CSS injected into Shadow DOM"
      contains: "leaflet.css?inline"
    - path: "src/widgets/route-browser/index.ts"
      provides: "Leaflet CSS injected into Shadow DOM"
      contains: "leaflet.css?inline"
  key_links:
    - from: "src/widgets/shared/widget-base.ts"
      to: ":host CSS"
      via: "applyStyleAttributes sets --widget-height and height on :host"
      pattern: "widget-height|data-height"
    - from: "each map widget render()"
      to: "Shadow DOM <style>"
      via: "Leaflet CSS string injected as <style> element into shadowRoot"
      pattern: "leafletCSS|leaflet.*inline"
    - from: "each map widget render()"
      to: "map.invalidateSize()"
      via: "requestAnimationFrame after map init triggers tile recalculation"
      pattern: "invalidateSize"
---

<objective>
Fix Leaflet map rendering on all standalone pages by injecting Leaflet CSS into Shadow DOM and fixing the CSS height chain.

Purpose: UAT revealed all 3 standalone map pages render broken tiles (random scattered squares) and wrong height. Root cause diagnosed as: (1) Leaflet CSS injected into document.head cannot penetrate Shadow DOM boundary, and (2) :host has no height property, breaking the CSS height chain for full-viewport layouts.

Output: All standalone pages render full-viewport Leaflet maps with contiguous tiles, correct zoom/pan, and proper height.
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-standalone-pages/13-01-SUMMARY.md
@.planning/phases/13-standalone-pages/13-UAT.md
@.planning/debug/leaflet-broken-tiles-standalone.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject Leaflet CSS into Shadow DOM for all map widgets</name>
  <files>
    src/widgets/heatmap-widget/index.ts
    src/widgets/pin-map-widget/index.ts
    src/widgets/route-browser/index.ts
    src/widgets/single-run-map/index.ts
    src/widgets/multi-run-overlay/index.ts
    src/widgets/map-test-widget/index.ts
  </files>
  <action>
    The core problem: `vite-plugin-css-injected-by-js` injects Leaflet CSS into `document.head`, but Leaflet map containers live inside Shadow DOM. Shadow DOM encapsulation blocks document-level CSS from reaching the map elements. Critical rules like `.leaflet-pane { position: absolute }` and `.leaflet-container { overflow: hidden }` never apply, causing random scattered tile squares.

    Fix: In each map widget's `render()` method (or `connectedCallback()` for map-test), inject Leaflet CSS directly into the Shadow DOM as a `<style>` element. Use Vite's `?inline` suffix to import CSS as a string instead of injecting into document.head.

    For each of the 6 map widget files:

    1. Change the Leaflet CSS import from:
       `import 'leaflet/dist/leaflet.css';`
       to:
       `import leafletCSS from 'leaflet/dist/leaflet.css?inline';`

    2. In the `render()` method (or `connectedCallback()` for map-test-widget), BEFORE creating the map container, inject the CSS into Shadow DOM:
       ```typescript
       const leafletStyle = document.createElement('style');
       leafletStyle.textContent = leafletCSS;
       this.shadowRoot!.appendChild(leafletStyle);
       ```

    3. For pin-map-widget ONLY, also inline the MarkerCluster CSS:
       Change:
       `import 'leaflet.markercluster/dist/MarkerCluster.css';`
       `import 'leaflet.markercluster/dist/MarkerCluster.Default.css';`
       to:
       `import markerClusterCSS from 'leaflet.markercluster/dist/MarkerCluster.css?inline';`
       `import markerClusterDefaultCSS from 'leaflet.markercluster/dist/MarkerCluster.Default.css?inline';`
       And inject both into Shadow DOM alongside leafletCSS.

    4. After creating the Leaflet map (after the `L.map(container)` call and tile layer), add an `invalidateSize()` call inside a `requestAnimationFrame` to force Leaflet to recalculate tile positions after Shadow DOM layout completes:
       ```typescript
       requestAnimationFrame(() => {
         this.map?.invalidateSize();
       });
       ```
       Place this AFTER the map initialization and tile layer addition, but BEFORE any data rendering (before renderHeatmapFromRoutes, renderPins, selectRoute, etc.). For widgets that call fitBounds, the invalidateSize must happen first so the bounds calculation uses correct container dimensions.

    IMPORTANT: The `?inline` suffix is a Vite feature. When Leaflet is externalized (external: ['leaflet'] in build config), the JS module is external but the CSS file is still in node_modules and can be imported with ?inline. This works because `?inline` is handled at build time by Vite's CSS pipeline, not at runtime.

    IMPORTANT: The existing `import 'leaflet/dist/leaflet.css'` (without ?inline) must be REMOVED, not kept alongside the inline import. Having both would cause Vite to still inject into document.head AND create an inline string.

    NOTE: For TypeScript, Vite's `?inline` imports may need a type declaration. Check if `src/vite-env.d.ts` or similar exists. If not, add a declaration:
    ```typescript
    declare module '*.css?inline' {
      const css: string;
      export default css;
    }
    ```
    Place this in `src/types/css-inline.d.ts` or in the existing vite-env.d.ts.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify TypeScript compilation succeeds.
    Run `npm run build-widgets` to verify build succeeds.
    Check built IIFE files for presence of Leaflet CSS string (search for "leaflet-pane" or "leaflet-tile" in the .iife.js files to confirm CSS is embedded as a string, not injected via document.head).
  </verify>
  <done>
    All 6 map widget source files import Leaflet CSS with `?inline` suffix and inject it into Shadow DOM as a `<style>` element. Each widget calls `map.invalidateSize()` in a `requestAnimationFrame` after map creation. TypeScript compiles. Build succeeds. The built IIFE bundles contain Leaflet CSS as inline strings injected into Shadow DOM.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix height chain - add data-height to WidgetBase and fix standalone page attributes</name>
  <files>
    src/widgets/shared/widget-base.ts
    src/pages/heatmap.html
    src/pages/pinmap.html
    src/pages/routes.html
  </files>
  <action>
    The secondary problem: `:host` in WidgetBase has no height property, and `data-height` is not in `observedAttributes` or `applyStyleAttributes()`. On standalone pages, the height chain breaks: `html,body(100dvh) -> custom-element(no height) -> shadow-root -> map-container(data-height)`. When `data-height="100%"` (heatmap.html), 100% of zero = zero. When `data-height` is absent (pinmap/routes), it defaults to 500px (not full viewport).

    Fix in TWO parts:

    PART A - WidgetBase (src/widgets/shared/widget-base.ts):

    1. Add `'data-height'` to the `observedAttributes` array (line 72-84), alongside the existing style attributes.

    2. Add `'data-height'` to the `isStyleAttribute()` method's `styleAttrs` array (line 171).

    3. In `applyStyleAttributes()` (line 178), add height handling:
       ```typescript
       const height = this.getAttribute('data-height');
       if (height) {
         this.style.setProperty('--widget-height', parseCSSValue(height, 'auto'));
         this.style.height = parseCSSValue(height, 'auto');
       }
       ```
       Setting BOTH the CSS variable AND the inline height is important. The CSS variable lets widgets reference it internally (e.g., route-browser uses --browser-height). The inline style.height sets the actual :host element height so percentage children resolve correctly.

    4. In the `BASE_WIDGET_STYLES` string, add `height: var(--widget-height, auto);` to the `:host` block. This goes after the `padding` line. Using `auto` as default means embedded widgets (which don't set data-height) get content-height behavior (unchanged from current behavior).

    PART B - Standalone pages:

    1. **heatmap.html**: Change `data-height="100%"` to `data-height="100dvh"`. Percentage heights require the parent to have an explicit height, but the custom element IS the parent and we're setting its height via this attribute. Using `100dvh` (dynamic viewport height) is an absolute unit that doesn't need a parent height chain. The `parseCSSValue` function in attribute-parser.ts handles arbitrary CSS values.

    2. **pinmap.html**: Add `data-height="100dvh"` to the `<pin-map-widget>` element. Currently missing entirely, causing 500px default.

    3. **routes.html**: Add `data-height="100dvh"` to the `<route-browser>` element. Currently missing entirely, causing 500px default.

    The final HTML elements should look like:
    - `<heatmap-widget data-height="100dvh" data-max-width="none" data-padding="0">`
    - `<pin-map-widget data-height="100dvh" data-max-width="none" data-padding="0">`
    - `<route-browser data-height="100dvh" data-max-width="none" data-padding="0">`

    IMPORTANT for route-browser: The route-browser widget uses `var(--browser-height, 500px)` for its internal grid layout height. After this change, when data-height="100dvh", the WidgetBase sets `--widget-height: 100dvh` and `style.height = '100dvh'`. The route-browser's render() method reads `this.getAttribute('data-height') || '500px'` and sets `--browser-height`. This already works correctly because the widget reads the attribute directly. No changes needed in route-browser's render() for this.

    REGRESSION CHECK: Existing embedded widgets that do NOT set `data-height` will get `height: var(--widget-height, auto)` which resolves to `auto` (content height) - identical to current behavior where :host has no height. This is safe.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify TypeScript compilation.
    Run `npm run build-widgets` to verify full build succeeds.
    Inspect the built standalone pages (dist/widgets/heatmap.html, pinmap.html, routes.html) to confirm data-height="100dvh" appears in each.
    Inspect the built IIFE bundles: check that widget-base CSS includes `--widget-height`.
  </verify>
  <done>
    WidgetBase observes `data-height`, applies it to :host element as both CSS variable and inline height. All 3 standalone pages use `data-height="100dvh"` for full-viewport maps. Embedded widgets without data-height default to `auto` (no regression). Build succeeds cleanly.
  </done>
</task>

</tasks>

<verification>
After both tasks are complete:

1. Build: `npm run build-widgets` completes without errors
2. TypeScript: `npx tsc --noEmit` passes
3. Standalone pages test (manual or serve):
   - `npx serve dist/widgets` (or `python3 -m http.server` from dist/widgets)
   - Open heatmap.html: Full-viewport heatmap with contiguous tiles, zoom/pan works
   - Open pinmap.html: Full-viewport pin map with visible pins, contiguous tiles
   - Open routes.html: Full-viewport route browser, sidebar + map fill viewport, tiles contiguous
4. Regression check:
   - Open index.html: All embedded widgets render at default heights (not broken)
   - Map widgets on index.html still show correct tiles (Shadow DOM CSS injection works for embedded too)
</verification>

<success_criteria>
- All 3 standalone pages show full-viewport (100dvh) Leaflet maps with contiguous tiles
- Leaflet zoom, pan, and controls work correctly on all standalone pages
- Pin map shows visible pins with clickable popups
- Route browser sidebar and map both fill the viewport height
- Embedded widgets on index.html are not regressed (same behavior as before)
- Build completes successfully with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-standalone-pages/13-02-SUMMARY.md`
</output>
