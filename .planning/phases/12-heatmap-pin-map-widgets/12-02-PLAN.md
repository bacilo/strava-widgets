---
phase: 12-heatmap-pin-map-widgets
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/widgets/pin-map-widget/index.ts
  - src/types/leaflet-markercluster.d.ts
  - scripts/build-widgets.mjs
  - package.json
autonomous: true
requirements: [PIN-01, PIN-02, PIN-03, PIN-04]

must_haves:
  truths:
    - "User can view a world map with pins for each city and country visited"
    - "User can click a pin to see run count, distance, and visit date range"
    - "User can toggle between country-level and city-level pin views"
    - "Pin size reflects activity count (larger pins for more activities)"
    - "Pin color reflects total distance (quintile-based color scale)"
  artifacts:
    - path: "src/widgets/pin-map-widget/index.ts"
      provides: "PinMapWidget custom element with city/country toggle, popups, and visual encoding"
      min_lines: 200
    - path: "src/types/leaflet-markercluster.d.ts"
      provides: "TypeScript declarations for leaflet.markercluster plugin"
      min_lines: 10
  key_links:
    - from: "src/widgets/pin-map-widget/index.ts"
      to: "data/geo/cities.json"
      via: "fetch city data for city-level pins"
      pattern: "fetch.*cities\\.json"
    - from: "src/widgets/pin-map-widget/index.ts"
      to: "data/geo/countries.json"
      via: "fetch country data for country-level pins"
      pattern: "fetch.*countries\\.json"
    - from: "src/widgets/pin-map-widget/index.ts"
      to: "data/geo/location-cache.json"
      via: "fetch coordinates for city markers"
      pattern: "fetch.*location-cache\\.json"
    - from: "src/widgets/pin-map-widget/index.ts"
      to: "data/geo/activity-cities.json"
      via: "fetch activity-to-city mapping for visit dates in popups"
      pattern: "fetch.*activity-cities\\.json"
    - from: "scripts/build-widgets.mjs"
      to: "src/widgets/pin-map-widget/index.ts"
      via: "widget build entry with isMapWidget: true"
      pattern: "pin-map-widget"
---

<objective>
Build the pin map widget that displays geographic markers for cities and countries visited, with an interactive toggle between aggregation levels, click popups showing statistics, and visual encoding of activity volume.

Purpose: Provide a geographic overview of running locations worldwide, showing where the user has run and how much activity occurred in each location.

Output: `<pin-map-widget>` custom element with city/country toggle, clickable markers showing run stats and visit date ranges, and size/color encoding reflecting activity count and distance.
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-heatmap-pin-map-widgets/12-RESEARCH.md
@.planning/phases/10-geocoding-foundation-map-infrastructure/10-03-SUMMARY.md
@scripts/build-widgets.mjs
@src/widgets/shared/widget-base.ts
@src/widgets/single-run-map/index.ts
@data/geo/cities.json
@data/geo/countries.json
@data/geo/location-cache.json
@data/geo/activity-cities.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install markercluster, create type declarations, and build core pin map widget</name>
  <files>
    package.json
    src/types/leaflet-markercluster.d.ts
    src/widgets/pin-map-widget/index.ts
    scripts/build-widgets.mjs
  </files>
  <action>
    1. Install leaflet.markercluster: `npm install leaflet.markercluster@^1.5.3`
       - Note: No reliable @types/leaflet.markercluster on npm. Create manual type declarations.

    2. Create `src/types/leaflet-markercluster.d.ts`:
       - Import 'leaflet' for L namespace extension
       - Declare MarkerClusterGroupOptions interface: maxClusterRadius, spiderfyOnMaxZoom, showCoverageOnHover, chunkedLoading (all optional)
       - Declare MarkerClusterGroup class extending L.FeatureGroup: constructor(options?), addLayer(layer), removeLayer(layer), clearLayers(), getChildCount()
       - Declare L.markerClusterGroup factory function
       - Ensure `import 'leaflet.markercluster'` side-effect import compiles

    3. Create `src/widgets/pin-map-widget/index.ts`:

       **Imports:**
       - Import L from 'leaflet', 'leaflet/dist/leaflet.css'
       - Import 'leaflet.markercluster' and 'leaflet.markercluster/dist/MarkerCluster.css' and 'leaflet.markercluster/dist/MarkerCluster.Default.css'
       - Import WidgetBase from shared
       - Import marker icon PNGs and fix default icons (same pattern as single-run-map)

       **Data interfaces (matching actual JSON structures from data/geo/):**
       ```
       interface CityData {
         cityName: string;
         countryName: string;
         countryIso2: string;
         activityCount: number;
         totalDistanceKm: number;
       }
       interface CountryData {
         countryName: string;
         countryIso2: string;
         activityCount: number;
         totalDistanceKm: number;
         cities: string[];
       }
       interface LocationEntry {
         cityName: string;
         countryName: string;
         countryIso2: string;
       }
       interface LocationCache {
         version: number;
         geocoder: string;
         entries: Record<string, LocationEntry>;
       }
       ```
       Note: activity-cities.json maps activity ID (string) -> string[] of city names

       **PinMapWidgetElement class extending WidgetBase:**

       Properties:
       - `private map: L.Map | null = null`
       - `private markerLayer: L.LayerGroup | null = null`
       - `private viewMode: 'country' | 'city' = 'country'`
       - `private cities: CityData[] = []`
       - `private countries: CountryData[] = []`
       - `private locationCache: LocationCache | null = null`
       - `private activityCities: Record<string, string[]> = {}`
       - `private allRouteData: Array<{id: number, date: string}> = []` (for visit date ranges)

       `protected get dataUrl()`: return 'data/geo/cities.json'

       `protected async fetchDataAndRender()` (override base class to fetch multiple data sources):
       - Fetch in parallel using Promise.all:
         - cities.json
         - countries.json
         - location-cache.json
         - activity-cities.json
         - data/routes/route-list.json (only need id and date for visit date ranges)
       - Store results in instance properties
       - Get initial view mode from data-view attribute ('country' or 'city', default 'country')
       - Get height from data-height attribute (default '500px')
       - Clear shadow DOM content (preserve styles)
       - Create wrapper div (position: relative)
       - Create map container div (100% width, height, border-radius: 8px, overflow hidden)
       - Append container to wrapper, wrapper to shadowRoot
       - Initialize Leaflet map: setView([30, 0], 2) (world view)
       - Add OpenStreetMap tile layer
       - Call renderPins()
       - Call renderToggleControls() and append to wrapper

       **Pin rendering:**

       `private renderPins()`:
       - Remove existing markerLayer if exists (call .remove())
       - If viewMode === 'country', call renderCountryPins()
       - If viewMode === 'city', call renderCityPins()

       `private renderCountryPins()`:
       - Create L.layerGroup() and add to map
       - For each country in this.countries:
         - Calculate centroid: average lat/lng of all cities in that country from location-cache entries matching countryIso2
         - If no coordinates found, skip (with console.warn)
         - Create scaled marker via createScaledMarker(coords, activityCount, totalDistanceKm)
         - Bind popup with formatCountryPopup(country)
         - Add marker to layer group

       `private renderCityPins()`:
       - Create L.markerClusterGroup({ maxClusterRadius: 50, spiderfyOnMaxZoom: true, showCoverageOnHover: false }) and add to map
       - For each city in this.cities:
         - Look up coordinates from location-cache: find entry where cityName and countryIso2 match
         - Fuzzy fallback: case-insensitive partial match if exact match fails
         - If no coordinates, skip (console.warn)
         - Create scaled marker
         - Bind popup with formatCityPopup(city)
         - Add marker to cluster group

       **Coordinate lookup:**

       `private getCountryCoordinates(country: CountryData): [number, number] | null`:
       - Find all entries in locationCache.entries where countryIso2 matches
       - Average their lat/lng (parse from cache key "lat,lng")
       - Return [avgLat, avgLng] or null if no entries found
       - Validate: lat -90..90, lng -180..180

       `private getCityCoordinates(cityName: string, countryIso2: string): [number, number] | null`:
       - Find entry in locationCache.entries where cityName matches AND countryIso2 matches
       - Fuzzy fallback: case-insensitive includes if exact match fails
       - Parse coordinates from cache key
       - Validate coordinates
       - Return or null

       **Visual encoding (PIN-04):**

       `private createScaledMarker(coords, activityCount, totalDistanceKm)`:
       - Calculate size: scale activityCount from range 1-maxActivities to 20-60px
         - maxActivities = Math.max(...this.cities.map(c => c.activityCount)) for dynamic scaling
       - Calculate color via getDistanceColor(totalDistanceKm)
       - Create L.divIcon with circular CSS:
         - border-radius: 50%, background: color, border: 3px solid white
         - box-shadow for depth, display flex + center for label
         - Show activity count as text inside circle (font-size scales with marker size)
       - iconSize and iconAnchor set to center the icon
       - Return L.marker(coords, { icon })

       `private getDistanceColor(distanceKm)`:
       - Quintile-based: >5000km=#fc4c02 (Strava orange), >2000=#ff6b35, >1000=#f7931e, >500=#fdc500, else #4ecdc4 (teal)

       **Popups (PIN-02):**

       `private formatCountryPopup(country: CountryData)`:
       - HTML popup with: country name (h3), activity count, total distance km (1 decimal), city list
       - Visit date range: find earliest and latest activity dates from route data matching country's cities
       - Format: "Month YYYY - Month YYYY" (e.g., "Feb 2023 - Oct 2025")

       `private formatCityPopup(city: CityData)`:
       - HTML popup with: city name (h3), country name, activity count, distance km
       - Visit date range: look up activity IDs from activityCities where city appears, find their dates from route data
       - Format first/last visit dates

       `private getVisitDateRange(cityNames: string[])`:
       - For each activity in activityCities, check if any city in cityNames is in the activity's city list
       - Collect matching activity dates from allRouteData
       - Return { first: Date, last: Date } or null

       **Toggle UI (PIN-03):**

       `private renderToggleControls()`:
       - Create container div (position: absolute, top: 10px, right: 10px, z-index: 1000)
       - Style: white bg, padding 8px, border-radius 8px, box-shadow
       - Two buttons: "Countries (N)" and "Cities (N)" where N is count from data
       - Active button: Strava orange bg, white text
       - On click: update viewMode, renderPins(), update active state
       - Return element

       **Cleanup:**
       `disconnectedCallback()`:
       - Remove markerLayer, remove map, call super

       **Registration:**
       `WidgetBase.register('pin-map-widget', PinMapWidgetElement)`

    4. Add pin-map-widget to `scripts/build-widgets.mjs`:
       - Add entry: `{ name: 'pin-map-widget', entry: resolve(__dirname, '../src/widgets/pin-map-widget/index.ts'), globalName: 'PinMapWidget', isMapWidget: true }`
       - leaflet.markercluster must also be externalized: Update the buildWidget function's external array for map widgets to include 'leaflet.markercluster' alongside 'leaflet'
       - OR bundle markercluster within the widget (since it's only 37KB and only used by this widget). Prefer bundling â€” simpler CDN setup.
       - DECISION: Do NOT externalize markercluster. Only externalize 'leaflet'. The CSS injection plugin will handle markercluster CSS. This avoids requiring an extra CDN script tag.

    5. Update test page (index.html):
       - Add widget element: `<pin-map-widget data-view="country"></pin-map-widget>`
       - Add the pin-map-widget IIFE script tag
       - Note: leaflet.markercluster is bundled in the widget, no extra CDN script needed

    6. Build and verify: `npm run build-widgets`
       - Verify pin-map-widget.iife.js is created
       - Verify bundle includes markercluster (will be larger than other map widgets, ~60-70KB acceptable)
       - Verify all other widgets still build successfully
  </action>
  <verify>
    - `npm ls leaflet.markercluster` shows installed
    - `npx tsc --noEmit` passes
    - `npm run build-widgets` succeeds
    - `dist/widgets/pin-map-widget.iife.js` exists
    - All previous widgets still build (check count: should be 11+ widget bundles including heatmap if 12-01 completed)
    - Bundle ends with `}(L);` confirming Leaflet externalization
  </verify>
  <done>
    Pin map widget renders city and country markers on world map, toggle switches between aggregation levels, click popups show run count/distance/visit dates, marker size reflects activity count, marker color reflects distance quintile, markercluster groups nearby city pins at low zoom levels
  </done>
</task>

</tasks>

<verification>
1. `npm run build-widgets` succeeds with pin-map-widget included
2. `npx tsc --noEmit` passes (all type declarations correct)
3. Pin map widget bundle builds successfully (Leaflet externalized, markercluster bundled)
4. All existing widget bundles build without regression
</verification>

<success_criteria>
- `<pin-map-widget>` custom element renders markers for cities and countries (PIN-01)
- Click popup shows run count, distance, and visit date range (PIN-02)
- Toggle UI switches between country-level and city-level views (PIN-03)
- Marker size proportional to activity count, color based on distance quintile (PIN-04)
- City-level view uses marker clustering for clean visualization at low zoom
</success_criteria>

<output>
After completion, create `.planning/phases/12-heatmap-pin-map-widgets/12-02-SUMMARY.md`
</output>
