---
phase: 12-heatmap-pin-map-widgets
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/compute-heatmap-data.mjs
  - data/heatmap/all-points.json
  - src/widgets/heatmap-widget/index.ts
  - src/widgets/heatmap-widget/color-schemes.ts
  - src/types/leaflet-heat.d.ts
  - scripts/build-widgets.mjs
  - package.json
autonomous: true
requirements: [HEAT-01, HEAT-02, HEAT-03, HEAT-04]

must_haves:
  truths:
    - "User can view all 1,808 runs overlaid as a heatmap on a single map"
    - "User can filter heatmap by date range (preset years and custom range)"
    - "User can switch between 5 color schemes (hot, cool, grayscale, viridis, strava)"
    - "Heatmap renders without blocking the UI (pre-decoded points, no client-side polyline decoding)"
  artifacts:
    - path: "scripts/compute-heatmap-data.mjs"
      provides: "Build-time polyline decoding to flat coordinate arrays"
      min_lines: 40
    - path: "data/heatmap/all-points.json"
      provides: "Pre-decoded heatmap points from all routes"
    - path: "src/widgets/heatmap-widget/index.ts"
      provides: "HeatmapWidget custom element with date filtering and color scheme UI"
      min_lines: 150
    - path: "src/widgets/heatmap-widget/color-schemes.ts"
      provides: "5 predefined gradient configurations for Leaflet.heat"
      min_lines: 30
    - path: "src/types/leaflet-heat.d.ts"
      provides: "TypeScript declarations for leaflet.heat plugin"
      min_lines: 10
  key_links:
    - from: "scripts/compute-heatmap-data.mjs"
      to: "data/heatmap/all-points.json"
      via: "polyline decode at build time"
      pattern: "polyline\\.decode"
    - from: "src/widgets/heatmap-widget/index.ts"
      to: "data/heatmap/all-points.json"
      via: "fetch pre-decoded points"
      pattern: "fetch.*all-points\\.json"
    - from: "src/widgets/heatmap-widget/index.ts"
      to: "src/widgets/heatmap-widget/color-schemes.ts"
      via: "import color scheme gradients"
      pattern: "import.*color-schemes"
    - from: "scripts/build-widgets.mjs"
      to: "src/widgets/heatmap-widget/index.ts"
      via: "widget build entry with isMapWidget: true"
      pattern: "heatmap-widget"
---

<objective>
Build the heatmap widget that overlays all running routes as a density heatmap on a Leaflet map, with date range filtering and color scheme customization.

Purpose: Provide a visual density overview of all 1,808 runs, enabling the user to see where they run most frequently and filter by time period.

Output: `<heatmap-widget>` custom element with pre-decoded points for instant rendering, 5 color schemes, and date range filtering (yearly presets + custom range).
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-heatmap-pin-map-widgets/12-RESEARCH.md
@.planning/phases/10-geocoding-foundation-map-infrastructure/10-03-SUMMARY.md
@.planning/phases/11-route-map-widgets/11-01-SUMMARY.md
@scripts/build-widgets.mjs
@src/widgets/shared/widget-base.ts
@src/widgets/single-run-map/index.ts
@src/widgets/shared/route-utils.ts
@scripts/compute-route-data.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install leaflet.heat, pre-compute heatmap data, and create color schemes</name>
  <files>
    package.json
    scripts/compute-heatmap-data.mjs
    data/heatmap/all-points.json
    src/widgets/heatmap-widget/color-schemes.ts
    src/types/leaflet-heat.d.ts
  </files>
  <action>
    1. Install leaflet.heat: `npm install leaflet.heat@^0.2.0`
       - Note: No @types/leaflet.heat exists on npm. Create manual type declarations instead.

    2. Create `src/types/leaflet-heat.d.ts` with TypeScript declarations for the leaflet.heat plugin:
       - Extend L namespace with heatLayer factory function
       - Declare HeatLayer class extending L.Layer with methods: setLatLngs, addLatLng, setOptions, redraw, getLatLngs
       - Declare HeatMapOptions interface with: minOpacity, maxZoom, max, radius, blur, gradient (Record<number, string>)
       - Export declarations so TypeScript recognizes `L.heatLayer()` and `L.HeatLayer`

    3. Create `src/widgets/heatmap-widget/color-schemes.ts`:
       - Export HeatmapGradient type: `Record<number, string>` (gradient stop position to color)
       - Export COLOR_SCHEMES record with 5 presets:
         - `hot`: navy -> blue -> green -> yellow -> red -> white (classic thermal)
         - `cool`: navy -> blue -> aqua -> light cyan -> white (blue-to-white)
         - `grayscale`: black -> gray -> white (accessibility-friendly)
         - `viridis`: dark purple -> blue -> green -> yellow (perceptually uniform, colorblind-safe)
         - `strava`: dark gray -> orange -> Strava orange (#fc4c02) -> bright orange (brand-aligned)
       - Export DEFAULT_SCHEME = 'strava'
       - Use the exact gradient values from 12-RESEARCH.md Pattern 2

    4. Create `scripts/compute-heatmap-data.mjs`:
       - Read `data/routes/route-list.json`
       - For each route with a polyline, decode using @mapbox/polyline
       - Store each route's points separately with metadata: `{ id, date, points: [[lat,lng], ...] }`
       - Write to `data/heatmap/all-points.json` as array of route point objects
       - Format: `[{ id: number, date: string, points: [number, number][] }, ...]`
       - This format enables client-side date filtering without re-decoding polylines
       - Log statistics: total routes processed, total points generated
       - IMPORTANT: This approach trades ~5MB file for zero client-side polyline decoding (HEAT-04)

    5. Run the script: `node scripts/compute-heatmap-data.mjs`
       - Verify data/heatmap/all-points.json is created
       - Verify it contains route entries with id, date, and points arrays

    6. Add npm script to package.json: `"compute-heatmap-data": "node scripts/compute-heatmap-data.mjs"`
  </action>
  <verify>
    - `npm ls leaflet.heat` shows installed
    - `npx tsc --noEmit` passes (type declarations valid)
    - `node scripts/compute-heatmap-data.mjs` runs without errors
    - `data/heatmap/all-points.json` exists and is valid JSON
    - File contains array of objects with id, date, and points fields
  </verify>
  <done>
    leaflet.heat installed, TypeScript declarations created, 5 color schemes defined, heatmap data pre-computed from all routes with per-route date metadata for client-side filtering
  </done>
</task>

<task type="auto">
  <name>Task 2: Create heatmap widget with date filtering, color scheme UI, and build integration</name>
  <files>
    src/widgets/heatmap-widget/index.ts
    scripts/build-widgets.mjs
  </files>
  <action>
    1. Create `src/widgets/heatmap-widget/index.ts`:

       **Imports and setup:**
       - Import L from 'leaflet', 'leaflet/dist/leaflet.css', 'leaflet.heat'
       - Import WidgetBase from shared
       - Import COLOR_SCHEMES and DEFAULT_SCHEME from ./color-schemes
       - Import marker icon PNGs and fix default icons (same pattern as single-run-map)

       **HeatmapRouteData interface:**
       - `{ id: number; date: string; points: [number, number][] }`

       **HeatmapWidgetElement class extending WidgetBase:**

       Properties:
       - `private map: L.Map | null = null`
       - `private heatLayer: L.HeatLayer | null = null` (use the type from leaflet-heat.d.ts)
       - `private allRoutes: HeatmapRouteData[] = []` (full unfiltered dataset)
       - `private currentScheme: string` (initialized from data-color-scheme attribute or DEFAULT_SCHEME)

       `protected get dataUrl()`: return 'data/heatmap/all-points.json'

       `protected render(data: unknown)`:
       - Clear shadow DOM content (preserve styles, same pattern as single-run-map)
       - Store allRoutes from data
       - Get height from data-height attribute (default '500px')
       - Create map container div (100% width, height from attribute, border-radius: 8px, overflow hidden)
       - Create a wrapper div (position: relative) that contains the map container
       - Append wrapper to shadowRoot
       - Initialize Leaflet map with setView([30, 0], 2) (world view)
       - Add OpenStreetMap tile layer (same as other map widgets)
       - Call renderHeatmapFromAllRoutes() with all routes
       - Call renderControls() to add filter and color scheme UI
       - Append controls to wrapper div (not shadow root directly, so they overlay the map)

       `private renderHeatmapFromRoutes(routes: HeatmapRouteData[])`:
       - Flatten all route points into single array: `const points = routes.flatMap(r => r.points)`
       - If heatLayer exists, remove it from map
       - Create new heatLayer: `L.heatLayer(points, this.getHeatmapOptions()).addTo(this.map!)`
       - Store reference in this.heatLayer
       - Auto-fit map bounds: create L.latLngBounds from points, map.fitBounds with 20px padding
       - CRITICAL (from research Pitfall 4): Gradient must be set at layer creation time. To change color scheme, remove and recreate layer, don't use setOptions.

       `private getHeatmapOptions()`:
       - Return object with: radius: 15, blur: 20, maxZoom: 13, max: 1.0, minOpacity: 0.4
       - gradient: COLOR_SCHEMES[this.currentScheme] || COLOR_SCHEMES[DEFAULT_SCHEME]

       **Date filtering (HEAT-02):**

       `private renderControls()`:
       - Create a controls container div with position: absolute, top: 10px, right: 10px, z-index: 1000
       - Style with white background, padding 12px, border-radius 8px, box-shadow, font-family system
       - Add date range section:
         - "Date Range:" label
         - Preset buttons: All Time, 2025, 2024, 2023 (derive years dynamically from allRoutes data range)
         - Custom date range: two HTML5 date inputs + Apply button
       - Add color scheme section:
         - "Color Scheme:" label
         - Buttons for each scheme in COLOR_SCHEMES (hot, cool, grayscale, viridis, strava)
         - Active button highlighted with Strava orange (#fc4c02) background
       - Add stats display: "Showing X runs" (updates on filter change)
       - Return the controls element

       `private applyDateFilter(preset: string)`:
       - Calculate start/end dates based on preset:
         - 'all-time': start = 2000-01-01
         - Year string (e.g. '2025'): start = Jan 1 of year, end = Dec 31 of year
       - Filter this.allRoutes by date range
       - Update stats display
       - Call renderHeatmapFromRoutes with filtered routes

       `private applyCustomDateFilter(startStr: string, endStr: string)`:
       - Parse dates, filter routes, update heatmap

       `private updateColorScheme(scheme: string)`:
       - Set this.currentScheme = scheme
       - Re-render heatmap with current filtered routes (remove and recreate layer per Pitfall 4)

       **Cleanup:**
       `disconnectedCallback()`:
       - Remove heatLayer if exists
       - Remove map if exists
       - Call super.disconnectedCallback()

       **Registration:**
       - `WidgetBase.register('heatmap-widget', HeatmapWidgetElement)`

    2. Add heatmap-widget to `scripts/build-widgets.mjs`:
       - Add entry: `{ name: 'heatmap-widget', entry: resolve(__dirname, '../src/widgets/heatmap-widget/index.ts'), globalName: 'HeatmapWidget', isMapWidget: true }`
       - Add 'data/heatmap' to the copyDataFiles dataDirs array: `{ src: 'data/heatmap', dest: 'dist/widgets/data/heatmap' }`

    3. Update test page (index.html) to include heatmap-widget:
       - Add Leaflet.heat CDN script after Leaflet CDN: `<script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>`
       - Add widget element: `<heatmap-widget data-color-scheme="strava"></heatmap-widget>`
       - Add the heatmap-widget IIFE script tag

    4. Build and verify: `npm run build-widgets`
       - Verify heatmap-widget.iife.js is created
       - Verify bundle size < 50KB (Leaflet and leaflet.heat externalized)
       - Verify all other widgets still build successfully
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run build-widgets` succeeds
    - `dist/widgets/heatmap-widget.iife.js` exists and is < 50KB
    - `dist/widgets/data/heatmap/all-points.json` is copied to dist
    - All previous widgets still build (check count: should be 10+ widget bundles)
    - Bundle ends with `}(L);` confirming Leaflet externalization
  </verify>
  <done>
    Heatmap widget renders all routes as density overlay, date filtering works with presets and custom range, 5 color schemes selectable via UI, leaflet.heat externalized via CDN, bundle < 50KB, all previous widgets unaffected
  </done>
</task>

</tasks>

<verification>
1. `npm run build-widgets` succeeds with heatmap-widget included
2. `npx tsc --noEmit` passes (all type declarations correct)
3. Heatmap widget bundle < 50KB
4. Pre-computed heatmap data exists at data/heatmap/all-points.json
5. All 10+ widget bundles build successfully (no regressions)
</verification>

<success_criteria>
- `<heatmap-widget>` custom element renders all routes as a density heatmap (HEAT-01)
- Date range filter UI with yearly presets and custom range (HEAT-02)
- 5 color scheme options selectable via UI buttons (HEAT-03)
- Zero client-side polyline decoding via pre-computed points (HEAT-04)
- Bundle size < 50KB with leaflet.heat externalized to CDN
</success_criteria>

<output>
After completion, create `.planning/phases/12-heatmap-pin-map-widgets/12-01-SUMMARY.md`
</output>
