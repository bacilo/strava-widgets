---
phase: 01-data-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/api/strava-client.ts
  - src/sync/activity-sync.ts
  - src/index.ts
autonomous: false
must_haves:
  truths:
    - "Developer can run a CLI command to trigger incremental sync of run activities"
    - "System fetches only activities newer than the last sync timestamp (high watermark)"
    - "System respects Strava rate limits via bottleneck (100 req/15min, serialized requests)"
    - "Only Run-type activities are saved; other activity types are filtered out"
    - "Each activity is saved as an individual JSON file in data/activities/"
    - "Sync state updates after each successful page fetch, enabling resume on failure"
    - "Developer can complete initial OAuth flow via CLI helper to obtain first tokens"
  artifacts:
    - path: "src/api/strava-client.ts"
      provides: "Rate-limited Strava API HTTP client"
      exports: ["StravaClient"]
      contains: "Bottleneck"
    - path: "src/sync/activity-sync.ts"
      provides: "Incremental activity sync orchestrator"
      exports: ["ActivitySync"]
      contains: "activity-sync"
    - path: "src/index.ts"
      provides: "CLI entry point with sync and auth commands"
      contains: "process.argv"
  key_links:
    - from: "src/index.ts"
      to: "src/sync/activity-sync.ts"
      via: "creates ActivitySync and calls syncNewActivities()"
      pattern: "ActivitySync.*syncNew"
    - from: "src/sync/activity-sync.ts"
      to: "src/api/strava-client.ts"
      via: "uses StravaClient to fetch paginated activities"
      pattern: "stravaClient.*getActivities"
    - from: "src/sync/activity-sync.ts"
      to: "src/storage/file-store.ts"
      via: "saves each activity as individual JSON file"
      pattern: "fileStore.*writeJson"
    - from: "src/sync/activity-sync.ts"
      to: "src/storage/sync-state.ts"
      via: "reads and updates high watermark after each page"
      pattern: "syncState.*(load|save|update)"
    - from: "src/api/strava-client.ts"
      to: "src/auth/strava-oauth.ts"
      via: "gets valid access token before each API request"
      pattern: "oauth.*getValidAccessToken"
    - from: "src/api/strava-client.ts"
      to: "bottleneck"
      via: "wraps all API calls in rate limiter"
      pattern: "limiter\\.schedule"
---

<objective>
Build the rate-limited Strava API client, incremental sync orchestrator, and CLI entry point.

Purpose: Complete the data pipeline so the developer can authenticate with Strava and incrementally sync run activities to local JSON storage. This plan wires together the foundation modules from Plan 01 into a working end-to-end flow: CLI command -> sync orchestrator -> rate-limited API client -> file storage.

Output: Working CLI tool that syncs Strava run activities incrementally with rate limit compliance.
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rate-limited Strava API client and sync orchestrator</name>
  <files>src/api/strava-client.ts, src/sync/activity-sync.ts</files>
  <action>
    **src/api/strava-client.ts** -- Rate-limited HTTP client for Strava API:
    - Export class `StravaClient` with constructor taking `{ oauth: StravaOAuth }`
    - Create a Bottleneck instance in constructor:
      ```
      reservoir: 100
      reservoirRefreshAmount: 100
      reservoirRefreshInterval: 15 * 60 * 1000  (15 minutes)
      maxConcurrent: 1  (serialize all requests)
      minTime: 200  (200ms minimum between requests as safety buffer)
      ```
    - `request<T>(endpoint: string): Promise<T>` -- wraps API call in `this.limiter.schedule()`:
      1. Get valid access token from oauth.getValidAccessToken()
      2. Fetch from `https://www.strava.com/api/v3${endpoint}` with Authorization Bearer header
      3. Log rate limit headers from response (X-ReadRateLimit-Limit, X-ReadRateLimit-Usage) at info level
      4. If response.status === 429: throw a specific RateLimitError with Retry-After header value
      5. If !response.ok: throw Error with status code and response text
      6. Return parsed JSON
    - `getActivities(params: { after?: number, page?: number, perPage?: number }): Promise<StravaActivity[]>` -- constructs URL with query params, calls request(). Default perPage to 200 (Strava maximum). Returns typed StravaActivity array.
    - Use p-retry to wrap the actual fetch call inside `request()` with: retries: 3, exponential backoff, only retry on network errors and 5xx (NOT 4xx client errors, NOT 429 which needs special handling).

    **src/sync/activity-sync.ts** -- Incremental sync orchestrator:
    - Export class `ActivitySync` with constructor taking `{ client: StravaClient, fileStore: FileStore, syncStateManager: SyncStateManager, activitiesDir: string }`
    - `syncNewActivities(): Promise<{ newRuns: number, totalFetched: number, pagesProcessed: number }>` -- the main sync method:
      1. Load current sync state via syncStateManager.load()
      2. Log starting sync from timestamp (or "beginning of time" if first sync)
      3. Paginate through activities using `client.getActivities({ after: state.last_sync_timestamp, page, perPage: 200 })`
      4. For each page:
         a. If empty array returned -> break (no more activities)
         b. Filter to only `type === 'Run'` activities
         c. Save each run as individual JSON file: `{activitiesDir}/{activity.id}.json`
         d. Update sync state with the highest timestamp from the page. Use `Math.floor(new Date(activity.start_date).getTime() / 1000)` for epoch seconds. IMPORTANT: Track the maximum timestamp across ALL activities in the page, not just the first one (activities may not be perfectly ordered).
         e. Save sync state after each page (enables resume on failure)
         f. Log progress: "Page {N}: {total} activities, {runs} runs saved"
      5. If `activities.length < perPage` -> break (last page reached)
      6. Increment page and continue
      7. Return summary stats
    - Handle the edge case where sync state has a last_sync_timestamp of 0 -- this means first sync, fetch all activities from the beginning.
    - Log final summary: "Sync complete: {newRuns} new runs saved ({totalFetched} total activities fetched across {pages} pages)"
  </action>
  <verify>
    1. Run `npx tsc --noEmit` -- zero compilation errors.
    2. Verify StravaClient uses Bottleneck: `grep "Bottleneck" src/api/strava-client.ts` returns match.
    3. Verify ActivitySync filters runs: `grep "type.*Run" src/sync/activity-sync.ts` returns match.
    4. Verify pagination exit condition: `grep "perPage\|length.*0" src/sync/activity-sync.ts` returns matches.
    5. Verify state saves per page: `grep "save\|update" src/sync/activity-sync.ts` returns matches inside the pagination loop.
  </verify>
  <done>
    StravaClient wraps all API calls in Bottleneck rate limiter (100/15min, serialized), uses p-retry for transient failures, and logs rate limit header values. ActivitySync performs paginated incremental fetch using high watermark, filters to Run type only, saves individual JSON files, updates sync state after each page, and exits on empty response or partial page.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI entry point with sync and auth commands</name>
  <files>src/index.ts</files>
  <action>
    **src/index.ts** -- CLI entry point that wires everything together:
    - Parse `process.argv[2]` as the command: `sync`, `auth`, or `status`
    - Import dotenv/config at top for env var loading

    **`auth` command:**
    1. Instantiate StravaOAuth from config
    2. If no argument after `auth`, print the authorization URL:
       `Visit this URL to authorize: {url}` with redirect_uri `http://localhost` and scope `activity:read`
    3. If `process.argv[3]` is provided, treat it as the authorization code:
       - Call oauth.exchangeCode(code)
       - Save tokens to config.tokensPath
       - Print "Tokens saved successfully. You can now run: npm run sync"

    **`sync` command:**
    1. Instantiate all dependencies using config values:
       - FileStore with baseDir from config.dataDir
       - StravaOAuth with clientId, clientSecret, tokensPath from config
       - StravaClient with the oauth instance
       - SyncStateManager with statePath from config, fileStore
       - ActivitySync with client, fileStore, syncStateManager, activitiesDir from config
    2. Call activitySync.syncNewActivities()
    3. Print results summary
    4. Exit with code 0 on success

    **`status` command:**
    1. Load sync state via SyncStateManager
    2. Print: last sync date, total activities, last activity ID
    3. Count JSON files in activities directory for verification
    4. If no sync state exists, print "No sync has been performed yet"

    **No command / `help`:**
    - Print usage: `Usage: npm run auth | npm run sync | npm start status`
    - List available commands with descriptions

    **Error handling:**
    - Wrap main logic in try/catch
    - On error: print error message to stderr, exit with code 1
    - Catch specific errors: missing env vars (suggest checking .env), missing tokens (suggest running auth first), rate limit exceeded (print wait time)
    - NEVER log tokens or secrets in error messages

    After creating index.ts, run full build: `npx tsc` to compile everything to dist/.
  </action>
  <verify>
    1. `npx tsc` compiles all files to dist/ with zero errors.
    2. `node dist/index.js help` prints usage information without errors.
    3. `node dist/index.js status` prints "No sync has been performed yet" (since no sync state exists).
    4. `node dist/index.js auth` prints an authorization URL containing `strava.com/oauth/authorize` and `activity:read` (will fail on missing env vars -- that's expected, verify the error message is descriptive).
    5. Verify no secrets in compiled output: `grep -r "secret\|password\|token" dist/ | grep -v "process.env\|STRAVA_\|refresh_token\|access_token\|Secret\|token"` should return nothing sensitive.
  </verify>
  <done>
    CLI entry point handles three commands (auth, sync, status). Auth command prints authorization URL and accepts authorization code to complete OAuth flow. Sync command wires all modules together and performs incremental activity sync. Status command shows sync state. Errors produce descriptive messages without leaking secrets. Full project compiles to dist/ with zero errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end OAuth and sync flow</name>
  <files>data/tokens.json, data/activities/, data/sync-state.json</files>
  <action>
    Human verifies the complete Strava data pipeline works end-to-end with real API credentials.
    Claude has automated everything: OAuth flow helper, rate-limited API client, incremental sync, and local storage.
    This checkpoint confirms the system works against the real Strava API with the user's actual account.
  </action>
  <verify>
    1. Copy .env.example to .env and fill in your Strava API credentials (STRAVA_CLIENT_ID, STRAVA_CLIENT_SECRET)
    2. Run `npm run auth` -- should print an authorization URL
    3. Visit the URL in browser, authorize the app, copy the `code` parameter from the redirect URL
    4. Run `node dist/index.js auth YOUR_CODE_HERE` -- should print "Tokens saved successfully"
    5. Run `npm run sync` -- should fetch your Strava activities and save runs as JSON files in data/activities/
    6. Check data/activities/ -- should contain .json files named by activity ID
    7. Run `npm run sync` again -- should report 0 new activities (incremental sync working)
    8. Run `npm start status` -- should show sync state with activity count
  </verify>
  <done>
    OAuth flow completes successfully, tokens are persisted, activities sync incrementally, only runs are saved, second sync reports no new activities, and status command shows accurate state.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc` compiles entire project with zero errors
2. `node dist/index.js help` prints usage without errors
3. `node dist/index.js auth` prints Strava authorization URL
4. After OAuth: `node dist/index.js auth CODE` saves tokens
5. `node dist/index.js sync` fetches activities, saves runs as JSON
6. Second sync fetches only new activities (incremental)
7. `node dist/index.js status` displays sync state
8. Rate limit headers logged during sync
9. data/activities/ contains individual .json files per run
10. data/sync-state.json contains valid high watermark
</verification>

<success_criteria>
- Developer can complete OAuth flow from CLI and obtain persisted tokens
- Incremental sync fetches only new activities using high watermark
- Rate limits enforced via Bottleneck (100 req/15min, serialized)
- Only Run-type activities saved to data/activities/
- Sync state persists between runs enabling incremental fetching
- CLI provides clear error messages for missing config or tokens
- Human verification confirms end-to-end flow works with real Strava data
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
