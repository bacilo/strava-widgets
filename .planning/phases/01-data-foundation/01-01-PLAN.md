---
phase: 01-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .gitignore
  - .env.example
  - src/config/strava.config.ts
  - src/types/strava.types.ts
  - src/auth/strava-oauth.ts
  - src/storage/file-store.ts
  - src/storage/sync-state.ts
autonomous: true
user_setup:
  - service: strava
    why: "OAuth credentials needed for Strava API access"
    env_vars:
      - name: STRAVA_CLIENT_ID
        source: "Strava Developer Settings -> My API Application -> Client ID"
      - name: STRAVA_CLIENT_SECRET
        source: "Strava Developer Settings -> My API Application -> Client Secret"
      - name: STRAVA_REFRESH_TOKEN
        source: "Obtained after completing OAuth flow (Plan 02 provides a helper script)"
    dashboard_config:
      - task: "Create or verify Strava API Application"
        location: "https://www.strava.com/settings/api"

must_haves:
  truths:
    - "Project initializes, installs dependencies, and compiles TypeScript without errors"
    - "Config module loads STRAVA_CLIENT_ID, STRAVA_CLIENT_SECRET, STRAVA_REFRESH_TOKEN from environment variables and throws descriptive errors if missing"
    - "OAuth module can refresh an expired access token and persist the rotated refresh token"
    - "File store writes activity JSON atomically (temp file + rename) and reads it back"
    - "Sync state persists and loads a high watermark timestamp for incremental sync tracking"
    - "Secrets (.env) are excluded from version control via .gitignore"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with dependencies"
      contains: "bottleneck"
    - path: "tsconfig.json"
      provides: "TypeScript compilation config"
      contains: "outDir"
    - path: ".gitignore"
      provides: "Git ignore rules"
      contains: ".env"
    - path: ".env.example"
      provides: "Template for required environment variables"
      contains: "STRAVA_CLIENT_ID"
    - path: "src/config/strava.config.ts"
      provides: "Centralized configuration from env vars"
      exports: ["config"]
    - path: "src/types/strava.types.ts"
      provides: "TypeScript types for Strava API responses and internal data"
      exports: ["StravaTokens", "StravaActivity", "SyncState"]
    - path: "src/auth/strava-oauth.ts"
      provides: "OAuth token management with refresh rotation"
      exports: ["StravaOAuth"]
    - path: "src/storage/file-store.ts"
      provides: "Atomic JSON file read/write operations"
      exports: ["FileStore"]
    - path: "src/storage/sync-state.ts"
      provides: "High watermark sync state persistence"
      exports: ["SyncStateManager"]
  key_links:
    - from: "src/auth/strava-oauth.ts"
      to: "src/config/strava.config.ts"
      via: "imports config for client_id, client_secret"
      pattern: "import.*config.*from.*strava\\.config"
    - from: "src/auth/strava-oauth.ts"
      to: "src/storage/file-store.ts"
      via: "persists rotated tokens to disk"
      pattern: "(writeJson|saveTokens)"
    - from: "src/storage/sync-state.ts"
      to: "src/storage/file-store.ts"
      via: "uses file store for atomic state persistence"
      pattern: "import.*from.*file-store"
---

<objective>
Initialize the project and build the foundation layers: config, types, OAuth auth, and local storage.

Purpose: Establish the TypeScript project with all dependencies and the lower-level modules that the API client and sync orchestrator (Plan 02) will depend on. After this plan, the project compiles, config loads from env vars, tokens can be refreshed, and data can be persisted atomically.

Output: A working TypeScript project with config, auth, and storage modules ready for the API/sync layer.
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize TypeScript project with dependencies</name>
  <files>package.json, tsconfig.json, .gitignore, .env.example</files>
  <action>
    1. Run `npm init -y` in the project root to create package.json.
    2. Update package.json: set `"name": "strava-analytics"`, `"type": "module"`, add scripts:
       - `"build": "tsc"`
       - `"start": "node dist/index.js"`
       - `"sync": "node dist/index.js sync"`
       - `"auth": "node dist/index.js auth"`
    3. Install production dependencies: `npm install dotenv bottleneck p-retry`
       Do NOT install simple-oauth2 -- the OAuth flow is simple enough (two fetch calls) that a manual implementation per research patterns is cleaner and avoids the dependency. The research listed it as an option but the code examples show manual fetch, which is sufficient.
    4. Install dev dependencies: `npm install -D typescript @types/node`
    5. Create tsconfig.json:
       ```json
       {
         "compilerOptions": {
           "target": "ES2022",
           "module": "Node16",
           "moduleResolution": "Node16",
           "outDir": "dist",
           "rootDir": "src",
           "strict": true,
           "esModuleInterop": true,
           "skipLibCheck": true,
           "forceConsistentCasingInFileNames": true,
           "resolveJsonModule": true,
           "declaration": true,
           "declarationMap": true,
           "sourceMap": true
         },
         "include": ["src/**/*"],
         "exclude": ["node_modules", "dist"]
       }
       ```
    6. Create .gitignore with: `node_modules/`, `dist/`, `.env`, `data/` (activity JSON storage), `.DS_Store`
    7. Create .env.example with placeholder values:
       ```
       STRAVA_CLIENT_ID=your_client_id_here
       STRAVA_CLIENT_SECRET=your_client_secret_here
       STRAVA_REFRESH_TOKEN=your_refresh_token_here
       ```
    8. Create directories: `src/config/`, `src/auth/`, `src/api/`, `src/storage/`, `src/sync/`, `src/types/`, `data/activities/`
  </action>
  <verify>
    Run `npx tsc --noEmit` (should succeed with no source files to compile, no errors).
    Run `node -e "require('./package.json')"` to verify package.json is valid JSON.
    Confirm .gitignore contains `.env` and `node_modules/`.
    Confirm .env.example exists with all three STRAVA_ variables.
  </verify>
  <done>
    Project has valid package.json with type:module, tsconfig.json targeting ES2022/Node16, all dependencies installed (dotenv, bottleneck, p-retry, typescript, @types/node), .gitignore blocks secrets and build artifacts, .env.example documents required env vars, directory structure created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config, types, OAuth auth, and storage modules</name>
  <files>src/types/strava.types.ts, src/config/strava.config.ts, src/auth/strava-oauth.ts, src/storage/file-store.ts, src/storage/sync-state.ts</files>
  <action>
    **src/types/strava.types.ts** -- Shared TypeScript types:
    - `StravaTokens`: `{ access_token: string, refresh_token: string, expires_at: number }` (expires_at is Unix epoch seconds)
    - `StravaActivity`: Interface matching Strava API response fields needed for analytics: `id` (number), `name` (string), `type` (string), `start_date` (string ISO 8601), `start_date_local` (string), `distance` (number, meters), `moving_time` (number, seconds), `elapsed_time` (number, seconds), `total_elevation_gain` (number, meters), `average_speed` (number, m/s), `max_speed` (number, m/s), `average_heartrate` (number, optional), `max_heartrate` (number, optional), `start_latlng` (number[] optional), `end_latlng` (number[] optional), `map` ({ summary_polyline: string } optional). Store full response so keep the type broad with an index signature `[key: string]: unknown` for future fields.
    - `SyncState`: `{ last_sync_timestamp: number, last_activity_id: string, total_activities: number, last_sync_date: string }`

    **src/config/strava.config.ts** -- Configuration from environment:
    - Import `dotenv/config` at top (side-effect import to load .env)
    - Export a `config` object with getters that throw descriptive errors if env vars are missing:
      - `clientId` -> STRAVA_CLIENT_ID
      - `clientSecret` -> STRAVA_CLIENT_SECRET
      - `refreshToken` -> STRAVA_REFRESH_TOKEN
      - `dataDir` -> STRAVA_DATA_DIR (default: `./data`)
      - `tokensPath` -> path.join(dataDir, 'tokens.json')
      - `syncStatePath` -> path.join(dataDir, 'sync-state.json')
      - `activitiesDir` -> path.join(dataDir, 'activities')
    - Use `path` module from Node.js for path construction
    - Config should be a plain object with lazy getters (not a class), since it's just env var access

    **src/auth/strava-oauth.ts** -- OAuth token management:
    - Export class `StravaOAuth` with constructor taking `{ clientId, clientSecret, tokensPath }` (not importing config directly -- accept via dependency injection for testability)
    - `getValidAccessToken(): Promise<string>` -- loads tokens from tokensPath, checks if `expires_at < (Date.now() / 1000) + 3600` (refresh 1 hour early per research), if expiring calls `refreshAccessToken`, saves new tokens, returns access_token
    - `refreshAccessToken(refreshToken: string): Promise<StravaTokens>` -- POST to `https://www.strava.com/oauth/token` with `{ client_id, client_secret, grant_type: 'refresh_token', refresh_token }`. Parse response as StravaTokens. Throw descriptive error on non-200.
    - `loadTokens(): Promise<StravaTokens>` -- reads tokensPath JSON file. Throws if file doesn't exist with message explaining user needs to complete OAuth flow first.
    - `saveTokens(tokens: StravaTokens): Promise<void>` -- uses FileStore to atomically write tokens to tokensPath. CRITICAL: Must persist new refresh_token on every refresh (Strava rotates refresh tokens).
    - `exchangeCode(code: string): Promise<StravaTokens>` -- POST to `https://www.strava.com/oauth/token` with `{ client_id, client_secret, code, grant_type: 'authorization_code' }`. For initial OAuth flow. Saves tokens after exchange.
    - `getAuthorizationUrl(redirectUri: string): string` -- constructs authorization URL with `activity:read` scope
    - Use native `fetch` (Node.js 18+), no external HTTP library

    **src/storage/file-store.ts** -- Atomic JSON file operations:
    - Export class `FileStore` with constructor taking `{ baseDir: string }`
    - `writeJson(filePath: string, data: unknown): Promise<void>` -- atomic write pattern: write to `${filePath}.tmp.${process.pid}`, then `rename(tempPath, filePath)`. Wrap in try/catch, clean up temp file on error. Use `fs/promises` for all operations. Create parent directories with `mkdir({ recursive: true })` if they don't exist.
    - `readJson<T>(filePath: string): Promise<T>` -- read file, JSON.parse, return typed result. Throw descriptive error if file not found or JSON invalid.
    - `exists(filePath: string): Promise<boolean>` -- check if file exists using `access()` from fs/promises
    - `listFiles(dirPath: string, extension?: string): Promise<string[]>` -- list files in directory, optionally filter by extension
    - Do NOT use write-file-atomic package -- the manual atomic write pattern (temp + rename) is simple enough and avoids the dependency, as shown in the research examples.

    **src/storage/sync-state.ts** -- High watermark tracking:
    - Export class `SyncStateManager` with constructor taking `{ statePath: string, fileStore: FileStore }`
    - `load(): Promise<SyncState>` -- loads sync state from statePath. If file doesn't exist, returns default: `{ last_sync_timestamp: 0, last_activity_id: '', total_activities: 0, last_sync_date: '' }`
    - `save(state: SyncState): Promise<void>` -- saves sync state atomically via fileStore
    - `updateAfterSync(activities: StravaActivity[]): Promise<SyncState>` -- takes array of newly synced activities, computes new high watermark from the most recent activity's start_date (converted to Unix epoch seconds), updates total_activities count, saves and returns updated state
  </action>
  <verify>
    1. Run `npx tsc --noEmit` -- project compiles with zero errors.
    2. Create a quick smoke test: add a temporary file `src/smoke-test.ts` that:
       - Imports FileStore, creates instance with baseDir='./data/test'
       - Writes a JSON object, reads it back, asserts equality
       - Imports SyncStateManager, loads default state, verifies defaults
       - Console.logs "All smoke tests passed"
    3. Run `npx tsc && node dist/smoke-test.js` -- should print success message.
    4. Delete the smoke test file and its compiled output after verification.
    5. Verify StravaOAuth has both `refreshAccessToken` and `exchangeCode` methods by checking the compiled output: `grep -c "refreshAccessToken\|exchangeCode" dist/auth/strava-oauth.js` should return 2+.
  </verify>
  <done>
    All five source files exist and compile. FileStore reads/writes JSON atomically. SyncStateManager loads defaults when no state file exists and persists state via FileStore. StravaOAuth has getValidAccessToken (with proactive refresh), refreshAccessToken (with token rotation persistence), exchangeCode (for initial setup), and getAuthorizationUrl. Config throws descriptive errors for missing env vars. Types cover StravaTokens, StravaActivity, and SyncState.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors (full type safety)
2. All 5 source files exist in their respective directories
3. FileStore atomic write works (write + read round-trip)
4. SyncStateManager returns sensible defaults for fresh state
5. No secrets present in any committed file (grep for "secret" in src/ returns only env var name references, not values)
6. .gitignore blocks .env, node_modules/, dist/, data/
</verification>

<success_criteria>
- TypeScript project compiles cleanly with strict mode
- Config module enforces presence of all required environment variables
- OAuth module implements token refresh with rotation persistence and code exchange
- FileStore performs atomic writes (temp file + rename pattern)
- SyncStateManager tracks high watermark with sensible defaults
- No secrets in version-controlled files
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-01-SUMMARY.md`
</output>
