---
phase: 10-geocoding-foundation-map-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - package.json
  - src/geo/polyline-decoder.ts
  - src/geo/compute-geo-stats.ts
  - scripts/compare-geocoding.mjs
autonomous: true

must_haves:
  truths:
    - "User sees all cities a run passes through in activity metadata (not just start city)"
    - "User can compare old vs new geocoding results to verify accuracy improvement"
  artifacts:
    - path: "src/geo/polyline-decoder.ts"
      provides: "Polyline decoding and route point sampling for multi-city detection"
      contains: "polyline.decode"
    - path: "src/geo/compute-geo-stats.ts"
      provides: "Multi-city detection integrated into geo stats pipeline"
      contains: "sampleRoutePoints"
    - path: "scripts/compare-geocoding.mjs"
      provides: "CLI comparison of old vs new geocoding results"
      contains: "v1"
  key_links:
    - from: "src/geo/polyline-decoder.ts"
      to: "@mapbox/polyline"
      via: "polyline.decode(summary_polyline)"
      pattern: "polyline\\.decode"
    - from: "src/geo/compute-geo-stats.ts"
      to: "src/geo/polyline-decoder.ts"
      via: "import decodeActivityPolyline, sampleRoutePoints"
      pattern: "import.*polyline-decoder"
    - from: "scripts/compare-geocoding.mjs"
      to: "data/geo/v1/"
      via: "reads old and new cities.json for diff"
      pattern: "data/geo/v1"
---

<objective>
Add polyline decoding for multi-city detection per run (GEO-02) and create a comparison script for old-vs-new geocoding results (GEO-03).

Purpose: GEO-02 requires tracking all cities a run passes through, not just the start city. GEO-03 requires a way to verify the geocoding accuracy improvement. Polyline data is already stored in activity JSON files (map.summary_polyline).
Output: polyline-decoder.ts module, updated compute-geo-stats with multi-city support, compare-geocoding CLI script.
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-geocoding-foundation-map-infrastructure/10-RESEARCH.md
@.planning/phases/10-geocoding-foundation-map-infrastructure/10-01-SUMMARY.md
@src/geo/geocoder.ts
@src/geo/compute-geo-stats.ts
@src/types/strava.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create polyline decoder and integrate multi-city detection into geo stats</name>
  <files>
    package.json
    src/geo/polyline-decoder.ts
    src/geo/compute-geo-stats.ts
  </files>
  <action>
    1. Install dependency:
       - `npm install @mapbox/polyline@^1.2.1`

    2. Create `src/geo/polyline-decoder.ts`:
       - Import `polyline from '@mapbox/polyline'`
       - Import `StravaActivity` type

       - Create `DecodedRoute` interface:
         ```typescript
         export interface DecodedRoute {
           activityId: number;
           coordinates: [number, number][]; // [[lat, lng], ...]
           bounds: { north: number; south: number; east: number; west: number; };
           pointCount: number;
         }
         ```

       - Create `decodeActivityPolyline(activity: StravaActivity): DecodedRoute | null`:
         - Return null if `!activity.map?.summary_polyline`
         - Call `polyline.decode(activity.map.summary_polyline)` — returns `[number, number][]` as [[lat, lng], ...]
         - Return null if decoded coords empty
         - Calculate bounds from min/max lat/lng
         - Return DecodedRoute object

       - Create `sampleRoutePoints(coordinates: [number, number][]): [number, number][]`:
         - Always include first and last point
         - For routes with <= 5 points, return all
         - Sample every Nth point where N = Math.floor(coordinates.length / 10) to get ~10 samples
         - This gives us start, end, and ~8 intermediate points for multi-city detection
         - Deduplicate the last point if it's the same as the last sampled point

    3. Update `src/geo/compute-geo-stats.ts` for multi-city detection:
       - Import `decodeActivityPolyline, sampleRoutePoints` from `./polyline-decoder.js`
       - After the existing single-location geocoding for each activity, add multi-city detection:
         - Decode the activity's polyline using `decodeActivityPolyline(activity)`
         - If polyline exists, call `sampleRoutePoints(decoded.coordinates)` to get sample points
         - For each sample point, call `geocodeActivity` with a synthetic partial activity object (just `start_latlng` set to the sample point)
           OR better: Create a small helper `geocodePoint(lat, lng, cache)` in geocoder.ts that geocodes a single coordinate (extract the core logic from geocodeActivity).
           Wait — to avoid modifying geocoder.ts (already modified in Plan 01), use a simpler approach:
           Create a local helper in compute-geo-stats.ts that calls the geocoder's coordToCacheKey and cache lookup directly.
           Actually the cleanest approach: add a `geocodeCoordinate(lat: number, lng: number, cache: GeoCache): GeoLocation | null` export to geocoder.ts. This is a small addition that won't conflict.
       - Collect all unique cities from sampled route points
       - Update the CityStats aggregation: each activity should count toward all cities it passes through (not just start city)
       - Update CountryStats similarly: each activity counts toward all countries it passes through
       - Add to the city aggregation: track `cities` per activity as an array in the metadata

       IMPORTANT design choice: The `start_latlng` geocoding remains the PRIMARY city for backward compatibility. Multi-city adds ADDITIONAL cities the route passes through. An activity's distance is attributed to the start city only (not split across cities) to keep the distance stats meaningful and comparable to v1 data.

       Implementation approach for multi-city:
       - Keep the existing start-city-based aggregation exactly as-is
       - Add a SEPARATE pass that collects all cities per activity from route sampling
       - Store multi-city data in a new output field in cities.json entries: don't change existing schema
       - Add a new output file `data/geo/activity-cities.json` mapping activity IDs to their city lists:
         ```json
         {
           "12345": ["Copenhagen", "Frederiksberg"],
           "12346": ["Roskilde"]
         }
         ```
       - This satisfies GEO-02 (user sees all cities) without breaking GEO-04 (existing widgets unchanged)

    4. Build and test:
       - `npm run build` — must compile
       - `npm run compute-geo-stats` — must run successfully, now with multi-city data
  </action>
  <verify>
    - `npm run build` — zero TypeScript errors
    - `npm run compute-geo-stats` — runs successfully, prints multi-city stats
    - `cat data/geo/activity-cities.json | head -20` — shows activity ID to city array mapping
    - `node -e "const d = require('./data/geo/activity-cities.json'); const multi = Object.values(d).filter(c => c.length > 1).length; console.log('Activities with multiple cities:', multi)"` — shows at least some activities with >1 city
    - `cat data/geo/cities.json` — existing schema unchanged (cityName, countryName, countryIso2, activityCount, totalDistanceKm)
  </verify>
  <done>
    Polyline decoder created, multi-city detection integrated into compute-geo-stats, activity-cities.json produced mapping activities to all cities they pass through. Existing cities.json schema unchanged (GEO-04).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create geocoding comparison script</name>
  <files>
    scripts/compare-geocoding.mjs
    package.json
  </files>
  <action>
    1. Create `scripts/compare-geocoding.mjs` — a Node.js script that compares old vs new geocoding results:
       - Read `data/geo/v1/cities.json` (old, UN/LOCODE) and `data/geo/cities.json` (new, GeoNames)
       - Read `data/geo/v1/countries.json` and `data/geo/countries.json`
       - Read `data/geo/v1/location-cache.json` and `data/geo/location-cache.json`

       - Print comparison report:
         ```
         === Geocoding Comparison: UN/LOCODE vs GeoNames ===

         SUMMARY:
           Old: X cities in Y countries
           New: X cities in Y countries
           Cache entries: old Z, new Z

         CITY NAME CHANGES (same coordinate, different city):
           38.76,-9.13: Alcochete -> Lisbon
           55.66,12.59: Roskilde -> Copenhagen
           ...

         NEW CITIES (in new but not old):
           ...

         REMOVED CITIES (in old but not new):
           ...

         COUNTRY CHANGES:
           ...
         ```

       - Compare location caches entry by entry:
         - For old cache (flat format: `{ "lat,lng": { cityName, ... } }`), iterate keys
         - For new cache (versioned format: `{ version, geocoder, entries: { "lat,lng": { ... } } }`), iterate entries
         - Find coordinates present in both, compare cityName values
         - Report additions, removals, and changes

    2. Add npm script to `package.json`:
       - `"compare-geocoding": "node scripts/compare-geocoding.mjs"`

    3. Run and verify output makes sense:
       - `npm run compare-geocoding` — should produce a readable diff report
  </action>
  <verify>
    - `npm run compare-geocoding` runs without errors and prints a comparison report
    - Report shows city name changes (at least some entries differ between old and new)
    - Report shows summary counts (cities and countries in old vs new)
    - Script handles missing v1 data gracefully (prints warning if data/geo/v1/ doesn't exist)
  </verify>
  <done>
    Comparison script exists at scripts/compare-geocoding.mjs, accessible via `npm run compare-geocoding`, produces human-readable diff report of old vs new geocoding results (GEO-03 complete).
  </done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. `npm run compute-geo-stats` runs end-to-end, producing activity-cities.json alongside existing output files
3. `npm run compare-geocoding` produces readable comparison report
4. `data/geo/activity-cities.json` maps activity IDs to city arrays, with some activities showing multiple cities
5. Existing cities.json and countries.json schema unchanged (GEO-04 preserved)
6. `npm test` passes (no regressions)
</verification>

<success_criteria>
- @mapbox/polyline installed and polyline-decoder.ts decodes Strava summary_polyline to coordinate arrays
- Multi-city detection runs on sampled route points, producing data/geo/activity-cities.json
- Comparison script (npm run compare-geocoding) shows old vs new city name differences
- Existing geographic data schema unchanged — widgets work without modification
</success_criteria>

<output>
After completion, create `.planning/phases/10-geocoding-foundation-map-infrastructure/10-02-SUMMARY.md`
</output>
