---
phase: 05-geocoding-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/geo/geocoder.ts
  - src/geo/cache-manager.ts
  - src/geo/compute-geo-stats.ts
  - src/index.ts
  - data/geo/location-cache.json
  - data/geo/countries.json
  - data/geo/cities.json
  - data/geo/geo-metadata.json
autonomous: true

must_haves:
  truths:
    - "Running `npm run compute-geo-stats` produces countries.json listing countries the user has run in, extracted from activity GPS coordinates"
    - "Running `npm run compute-geo-stats` produces cities.json listing cities the user has run in, extracted from activity GPS coordinates"
    - "Activities without GPS data (start_latlng null/missing) are excluded from geocoding and geo-metadata.json shows coverage indicator (geocodedActivities vs totalActivities)"
    - "Geocoding uses offline-geocode-city library with zero API calls"
    - "Location cache persists across runs — second execution is near-instant due to >90% cache hit rate"
  artifacts:
    - path: "src/geo/geocoder.ts"
      provides: "Offline reverse geocoding wrapper with coordinate rounding and caching"
      exports: ["geocodeActivity", "GeoLocation", "GeoCache"]
    - path: "src/geo/cache-manager.ts"
      provides: "File-based cache load/save for location-cache.json"
      exports: ["loadCache", "saveCache"]
    - path: "src/geo/compute-geo-stats.ts"
      provides: "Build-time script that geocodes all Run activities and writes countries.json, cities.json, geo-metadata.json"
      exports: ["computeGeoStats"]
    - path: "data/geo/countries.json"
      provides: "Aggregated country list with activity counts and city lists"
    - path: "data/geo/cities.json"
      provides: "Aggregated city list with activity counts and country association"
    - path: "data/geo/geo-metadata.json"
      provides: "Coverage stats: totalActivities, geocodedActivities, coveragePercent, cacheSize"
    - path: "data/geo/location-cache.json"
      provides: "Persistent coordinate-to-location cache (git-tracked)"
  key_links:
    - from: "src/geo/compute-geo-stats.ts"
      to: "src/geo/geocoder.ts"
      via: "import geocodeActivity"
      pattern: "import.*geocodeActivity.*from.*geocoder"
    - from: "src/geo/compute-geo-stats.ts"
      to: "src/geo/cache-manager.ts"
      via: "import loadCache, saveCache"
      pattern: "import.*loadCache.*saveCache.*from.*cache-manager"
    - from: "src/geo/geocoder.ts"
      to: "offline-geocode-city"
      via: "import getNearestCity"
      pattern: "import.*getNearestCity.*from.*offline-geocode-city"
    - from: "src/index.ts"
      to: "src/geo/compute-geo-stats.ts"
      via: "import computeGeoStats"
      pattern: "import.*computeGeoStats.*from.*geo/compute-geo-stats"
---

<objective>
Build the offline geocoding pipeline that extracts country and city locations from Strava activity GPS coordinates.

Purpose: Enable geographic data extraction (GEO-01, GEO-02, GEO-03) — the foundation for all geographic features in v1.1. This pipeline runs at build time, produces static JSON files consumed by future widgets, and caches results for fast subsequent builds.

Output: `npm run compute-geo-stats` command that reads activity files, geocodes GPS coordinates using offline-geocode-city, and writes countries.json, cities.json, geo-metadata.json, and location-cache.json to data/geo/.
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-geocoding-infrastructure/05-RESEARCH.md
@src/analytics/compute-stats.ts
@src/index.ts
@src/types/strava.types.ts
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create geocoder and cache modules</name>
  <files>
    package.json
    src/geo/geocoder.ts
    src/geo/cache-manager.ts
  </files>
  <action>
1. Install offline-geocode-city:
   ```bash
   npm install offline-geocode-city
   ```

2. Create `src/geo/geocoder.ts` — Wrapper around offline-geocode-city with coordinate rounding and cache integration:
   - Export `GeoLocation` interface: `{ cityName: string; countryName: string; countryIso2: string }`
   - Export `GeoCache` interface: `{ [coordKey: string]: GeoLocation }` (e.g., `"38.7600,-9.1200"` → location)
   - Implement `roundCoord(coord: number, decimals: number = 4): number` — round to 4 decimals (≈11m precision, sufficient for city-level)
   - Implement `coordToCacheKey(lat: number, lng: number): string` — returns `"${roundCoord(lat)},${roundCoord(lng)}"`
   - Export `geocodeActivity(activity: StravaActivity, cache: GeoCache): GeoLocation | null`:
     - Guard: Return null if `!activity.start_latlng || activity.start_latlng.length !== 2`
     - Guard: Validate lat is -90..90, lng is -180..180 (reject invalid coordinates)
     - Check cache by rounded coord key — return cached if found
     - Call `getNearestCity(lat, lng)` from offline-geocode-city
     - Guard: Return null if result is undefined or missing cityName/countryName
     - Store in cache and return GeoLocation
   - Import: `import { getNearestCity } from 'offline-geocode-city';`
   - Import: `import type { StravaActivity } from '../types/strava.types.js';`

3. Create `src/geo/cache-manager.ts` — Load/save JSON cache from disk:
   - Export `loadCache(path: string): Promise<GeoCache>`:
     - Try `fs.readFile(path, 'utf-8')` → `JSON.parse` → return cache
     - Catch ENOENT: log "Cache not found, starting fresh" → return empty `{}`
     - Rethrow other errors
   - Export `saveCache(path: string, cache: GeoCache): Promise<void>`:
     - Create parent directory with `fs.mkdir(dir, { recursive: true })`
     - Write with `JSON.stringify(cache, null, 2)` for git-friendly diffs
     - Log cache size
   - Import `GeoCache` from `./geocoder.js`
   - Use `import * as fs from 'fs/promises';` (following existing pattern in compute-stats.ts)
  </action>
  <verify>
Run `npm run build` — TypeScript compilation succeeds with no errors in src/geo/ files.
  </verify>
  <done>
geocoder.ts exports geocodeActivity, GeoLocation, GeoCache. cache-manager.ts exports loadCache, saveCache. Both compile cleanly. offline-geocode-city is in package.json dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create compute-geo-stats script and CLI integration</name>
  <files>
    src/geo/compute-geo-stats.ts
    src/index.ts
    package.json
  </files>
  <action>
1. Create `src/geo/compute-geo-stats.ts` — Build script following the pattern of `src/analytics/compute-stats.ts`:
   - Export `computeGeoStats(options?: { activitiesDir?: string; geoDir?: string }): Promise<void>`
   - Default activitiesDir: `'data/activities'`, geoDir: `'data/geo'`
   - Step 1: Read all JSON files from activitiesDir, filter to `activity.type === 'Run'` (same pattern as compute-stats.ts lines 43-57)
   - Step 2: Load cache via `loadCache(path.join(geoDir, 'location-cache.json'))`
   - Step 3: Iterate activities, call `geocodeActivity(activity, cache)` for each. Track successCount and totalCount.
   - Step 4: Save updated cache via `saveCache(path.join(geoDir, 'location-cache.json'), cache)`
   - Step 5: Aggregate countries — Map keyed by `countryIso2`:
     ```typescript
     interface CountryStats {
       countryName: string;
       countryIso2: string;
       activityCount: number;
       cities: string[]; // Unique city names in this country
     }
     ```
     Sort by activityCount descending before writing.
   - Step 6: Aggregate cities — Map keyed by `${cityName},${countryIso2}`:
     ```typescript
     interface CityStats {
       cityName: string;
       countryName: string;
       countryIso2: string;
       activityCount: number;
     }
     ```
     Sort by activityCount descending before writing.
   - Step 7: Create geoDir with `fs.mkdir(geoDir, { recursive: true })`
   - Step 8: Write three JSON files with `JSON.stringify(data, null, 2)`:
     - `countries.json` — Array of CountryStats
     - `cities.json` — Array of CityStats
     - `geo-metadata.json`:
       ```typescript
       {
         generatedAt: new Date().toISOString(),
         totalActivities: number,
         geocodedActivities: number,
         coveragePercent: Math.round((successCount / totalCount) * 100),
         cacheSize: Object.keys(cache).length
       }
       ```
   - Step 9: Console log summary: `Geocoded {successCount} of {totalCount} activities ({coveragePercent}%)`
   - Handle edge case: If totalCount is 0, set coveragePercent to 0 (avoid division by zero)

2. Add CLI command to `src/index.ts`:
   - Add import at top: `import { computeGeoStats } from './geo/compute-geo-stats.js';`
   - Add `computeGeoStatsCommand` async function (follow existing computeStatsCommand pattern at lines 130-146):
     ```typescript
     async function computeGeoStatsCommand() {
       try {
         console.log('Computing geographic statistics from synced activities...\n');
         await computeGeoStats({
           activitiesDir: config.activitiesDir,
           geoDir: 'data/geo',
         });
         console.log('\nGeographic statistics generated successfully!');
         process.exit(0);
       } catch (error: any) {
         console.error('Compute geo stats error:', error.message);
         if (error.code === 'ENOENT' && error.message.includes('activities')) {
           console.error('\nActivities directory not found. Please run: npm run sync');
         }
         process.exit(1);
       }
     }
     ```
   - Add case `'compute-geo-stats':` to switch statement (before `'help'`)
   - Update `computeAllStatsCommand` to also call `computeGeoStats` after advanced stats (so `npm run process` includes geo stats)
   - Update `printHelp` to include `compute-geo-stats` command

3. Add npm script to `package.json`:
   - Add `"compute-geo-stats": "node dist/index.js compute-geo-stats"` to scripts section

4. Run against real data and verify:
   ```bash
   npm run build && npm run compute-geo-stats
   ```
   - Verify `data/geo/countries.json` exists and contains entries with countryName, countryIso2, activityCount, cities
   - Verify `data/geo/cities.json` exists and contains entries with cityName, countryName, activityCount
   - Verify `data/geo/geo-metadata.json` exists and shows totalActivities, geocodedActivities, coveragePercent
   - Verify `data/geo/location-cache.json` exists and contains cached entries
   - Run a second time to verify cache hit rate is >90% (console output should show fast execution)
  </action>
  <verify>
Run these commands and verify:
1. `npm run build` — compiles without errors
2. `npm run compute-geo-stats` — prints geocoding summary (e.g., "Geocoded 1620 of 1808 activities (90%)")
3. `cat data/geo/countries.json | head -20` — shows valid JSON array of country objects
4. `cat data/geo/cities.json | head -20` — shows valid JSON array of city objects
5. `cat data/geo/geo-metadata.json` — shows totalActivities, geocodedActivities, coveragePercent, cacheSize
6. `ls -la data/geo/location-cache.json` — file exists with non-zero size
7. Run `npm run compute-geo-stats` a second time — should complete significantly faster (cache hits)
  </verify>
  <done>
`npm run compute-geo-stats` produces countries.json, cities.json, geo-metadata.json, and location-cache.json in data/geo/. Coverage metadata shows geocoded vs total activities with percentage. Cache persists for fast subsequent builds. CLI help shows the new command. `compute-all-stats` includes geo stats computation.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` — TypeScript compiles all src/geo/ files without errors
2. `npm run compute-geo-stats` — runs successfully, prints geocoding summary
3. `data/geo/countries.json` — valid JSON array, each entry has countryName, countryIso2, activityCount, cities
4. `data/geo/cities.json` — valid JSON array, each entry has cityName, countryName, countryIso2, activityCount
5. `data/geo/geo-metadata.json` — has totalActivities, geocodedActivities, coveragePercent (>0), cacheSize
6. `data/geo/location-cache.json` — exists, git-trackable, contains cached coordinate lookups
7. Second run of `npm run compute-geo-stats` completes faster (cache hits logged or faster execution time)
8. `npm run compute-all-stats` includes geo stats (no separate manual step needed)
9. No runtime API calls — all geocoding uses offline-geocode-city library
</verification>

<success_criteria>
- countries.json and cities.json contain real geographic data extracted from activity GPS coordinates
- geo-metadata.json shows coverage percentage (activities with GPS data vs total)
- Activities without start_latlng are gracefully excluded (not errors)
- location-cache.json persists coordinate lookups for fast rebuilds
- CLI command `compute-geo-stats` is accessible via npm script and integrated into `compute-all-stats`
</success_criteria>

<output>
After completion, create `.planning/phases/05-geocoding-infrastructure/05-01-SUMMARY.md`
</output>
