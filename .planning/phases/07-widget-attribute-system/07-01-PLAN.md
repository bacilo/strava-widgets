---
phase: 07-widget-attribute-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/widgets/shared/attribute-parser.ts
  - src/widgets/shared/theme-manager.ts
  - src/widgets/shared/responsive-manager.ts
  - src/widgets/shared/widget-base.ts
  - src/types/widget-config.types.ts
autonomous: true

must_haves:
  truths:
    - "Attribute parser converts string attributes to typed values with safe defaults"
    - "Theme manager detects system dark/light preference and responds to data-theme attribute"
    - "Responsive manager detects container size changes via ResizeObserver"
    - "Widget base class extends HTMLElement and reads configuration from data-attributes"
  artifacts:
    - path: "src/widgets/shared/attribute-parser.ts"
      provides: "Type-safe attribute parsing utilities"
      exports: ["parseBoolean", "parseNumber", "parseJSON", "parseColor", "parseEnum", "parseCSSValue"]
    - path: "src/widgets/shared/theme-manager.ts"
      provides: "Dark/light mode detection and CSS custom property injection"
      exports: ["ThemeManager"]
    - path: "src/widgets/shared/responsive-manager.ts"
      provides: "ResizeObserver wrapper with loop prevention"
      exports: ["ResponsiveManager"]
    - path: "src/widgets/shared/widget-base.ts"
      provides: "HTMLElement-based widget base class with attribute support"
      exports: ["WidgetBase"]
  key_links:
    - from: "src/widgets/shared/widget-base.ts"
      to: "src/widgets/shared/attribute-parser.ts"
      via: "import and use in getConfig()"
      pattern: "import.*attribute-parser"
    - from: "src/widgets/shared/widget-base.ts"
      to: "src/widgets/shared/theme-manager.ts"
      via: "ThemeManager instance in connectedCallback"
      pattern: "ThemeManager"
    - from: "src/widgets/shared/widget-base.ts"
      to: "src/widgets/shared/responsive-manager.ts"
      via: "ResponsiveManager instance in connectedCallback"
      pattern: "ResponsiveManager"
---

<objective>
Create the shared attribute infrastructure that all widgets will use: type-safe attribute parsers, theme manager for dark/light mode, responsive container detection, and refactor WidgetBase from a plain class to an HTMLElement-based Custom Element that reads configuration from HTML data-attributes.

Purpose: This is the foundation for Phase 7 -- without this infrastructure, individual widgets cannot be configured via HTML attributes. All four widgets (stats-card, comparison-chart, streak-widget, geo-stats-widget) will extend this base in subsequent plans.

Output: Four shared modules (attribute-parser, theme-manager, responsive-manager, widget-base) that provide a complete Custom Element lifecycle with attribute-driven configuration.
</objective>

<execution_context>
@/Users/pedf/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pedf/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-widget-attribute-system/07-RESEARCH.md
@src/widgets/shared/widget-base.ts
@src/types/widget-config.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create attribute parser, theme manager, and responsive manager utilities</name>
  <files>
    src/widgets/shared/attribute-parser.ts
    src/widgets/shared/theme-manager.ts
    src/widgets/shared/responsive-manager.ts
  </files>
  <action>
Create three new utility modules in src/widgets/shared/:

**attribute-parser.ts** - Static utility functions for type-safe attribute parsing:
- `parseBoolean(element: HTMLElement, attrName: string, defaultValue?: boolean): boolean` -- Use `hasAttribute()` for presence detection (NOT getAttribute === 'true'). Default false.
- `parseNumber(value: string | null, defaultValue: number, min?: number, max?: number): number` -- parseFloat with explicit isNaN check. Clamp to min/max if provided. Warn on invalid input via console.warn.
- `parseJSON<T>(value: string | null, defaultValue: T): T` -- JSON.parse wrapped in try/catch. Warn and return default on failure.
- `parseColor(value: string | null, defaultValue: string): string` -- Validate via temporary div.style.color approach (set value, check if browser accepted it). Return default if invalid.
- `parseEnum<T extends string>(value: string | null, allowedValues: readonly T[], defaultValue: T): T` -- Whitelist check. Warn on invalid.
- `parseCSSValue(value: string | null, defaultValue: string): string` -- If value is pure number, append 'px'. If value contains units (%, px, em, rem, vh, vw), pass through. Return default if null.

All functions are pure (no side effects except console.warn) and exported individually (no class).

**theme-manager.ts** - ThemeManager class:
- Constructor takes the host HTMLElement
- `getEffectiveTheme(): 'light' | 'dark'` -- reads data-theme attribute. If 'light' or 'dark', return directly. If 'auto' or absent, detect via `window.matchMedia('(prefers-color-scheme: dark)')`.
- `applyTheme(shadowRoot: ShadowRoot): void` -- Injects CSS with :host theme selectors using CSS custom properties. Light theme: --widget-bg: #ffffff, --widget-text: #333333, --widget-accent: #fc4c02. Dark theme: --widget-bg: #1a1a2e, --widget-text: #e0e0e0, --widget-accent: #ff6b35. Uses both @media (prefers-color-scheme: dark) for auto mode AND :host([data-theme="dark"]) for manual override.
- `listenForChanges(callback: () => void): void` -- Adds matchMedia change listener. Stores reference for cleanup.
- `destroy(): void` -- Removes matchMedia listener.

**responsive-manager.ts** - ResponsiveManager class:
- Constructor takes host HTMLElement and a callback `(width: number, height: number) => void`
- Creates ResizeObserver that wraps callback in requestAnimationFrame
- Tracks expected sizes via WeakMap to prevent infinite loops (per research pitfall #4)
- Uses contentBoxSize[0].inlineSize/blockSize with contentRect fallback
- `observe(): void` -- starts observing the host element
- `disconnect(): void` -- disconnects the observer
- Sets a `data-size` attribute on the host: 'compact' (<400px), 'medium' (400-699px), 'large' (>=700px) -- this enables CSS-only responsive styling via :host([data-size="compact"]) selectors

Do NOT import Chart.js or any external libraries in these utility modules. They must be zero-dependency (only DOM APIs).
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile without errors. Verify all three files exist and export the expected functions/classes by checking import resolution.
  </verify>
  <done>
Three utility modules exist with correct exports: attribute-parser.ts (6 functions), theme-manager.ts (ThemeManager class), responsive-manager.ts (ResponsiveManager class). TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor WidgetBase to extend HTMLElement with attribute-driven configuration</name>
  <files>
    src/widgets/shared/widget-base.ts
    src/types/widget-config.types.ts
  </files>
  <action>
Refactor WidgetBase from a plain class with constructor(containerId, config) to an abstract class extending HTMLElement with Custom Element lifecycle. This is a BREAKING change to the widget base -- subsequent plans will update each widget.

**widget-base.ts changes:**

1. Change class signature: `export abstract class WidgetBase extends HTMLElement` (remove generic `<T>` -- subclasses will handle their own data types)

2. Define static `observedAttributes` on the base class with common attributes ALL widgets support:
   - `data-url` (primary data URL, replaces config.dataUrl)
   - `data-url-secondary` (replaces config.options.secondaryDataUrl)
   - `data-title` (replaces config.options.customTitle)
   - `data-show-title` (boolean, replaces config.options.showTitle)
   - `data-theme` (enum: 'light' | 'dark' | 'auto', default 'auto')
   - `data-width` (CSS value, replaces config.size.width)
   - `data-max-width` (CSS value, replaces config.size.maxWidth)
   - `data-padding` (CSS value, replaces config.size.padding)
   - `data-bg` (color, replaces config.colors.background)
   - `data-text-color` (color, replaces config.colors.text)
   - `data-accent` (color, replaces config.colors.accent)

3. Implement Custom Element lifecycle:
   - `constructor()`: Call super(). Attach Shadow DOM (mode: 'open'). Do NOT read attributes here (not available yet per spec).
   - `connectedCallback()`: Read all attributes via the parser utilities. Initialize ThemeManager. Initialize ResponsiveManager. Show loading state. Call `this.fetchDataAndRender()`.
   - `attributeChangedCallback(name, oldValue, newValue)`: Skip if oldValue === newValue. If theme-related, update theme. For other attributes, call a full re-render (debounce not needed for static HTML usage).
   - `disconnectedCallback()`: Clean up ThemeManager and ResponsiveManager.

4. Provide a protected `getConfig()` method that reads current attributes and returns a WidgetConfig-compatible object (for backwards compatibility during migration). Uses attribute-parser functions internally.

5. Keep the existing `fetchData<T>(url)`, `showLoading()`, `showError()` methods. Update `fetchDataAndRender()` to use `this.getAttribute('data-url')` instead of `this.config.dataUrl`.

6. Inject BASE_WIDGET_STYLES with additional theme-aware CSS:
   - Container queries: `:host { container-type: inline-size; }` for CSS-only responsive
   - Dark mode styles via `:host([data-theme="dark"])` and `@media (prefers-color-scheme: dark) :host(:not([data-theme="light"]))` selectors
   - Responsive styles via `:host([data-size="compact"])`, `:host([data-size="medium"])`, `:host([data-size="large"])`

7. Subclasses must implement: `abstract render(data: unknown): void` and `abstract get dataUrl(): string` (returns getAttribute('data-url') or widget-specific default)

8. Add a static `register(tagName: string, ElementClass: typeof WidgetBase)` helper that calls `customElements.define(tagName, ElementClass)` with a check for duplicate registration.

**widget-config.types.ts changes:**

Keep the existing WidgetConfig interface (do not remove it -- it serves as the shape for getConfig() return and backwards compat). No changes needed.

**IMPORTANT CONSTRAINTS:**
- Do NOT update any individual widget files in this task -- that happens in Plans 02 and 03.
- The old WidgetBase constructor signature (containerId, config) is REMOVED. Subclasses will need updating.
- Keep all existing CSS custom property names (--widget-bg, --widget-text, --widget-accent, --widget-width, --widget-max-width, --widget-padding) for continuity.
  </action>
  <verify>
Run `npx tsc --noEmit` -- expect compilation ERRORS in the individual widget files (stats-card, comparison-chart, streak-widget, geo-stats-widget) because they still use the old constructor signature. This is expected and will be fixed in Plans 02 and 03. Verify by checking that the errors are ONLY in src/widgets/*/index.ts files, not in the shared modules themselves.

To verify shared modules compile in isolation: `npx tsc --noEmit src/widgets/shared/widget-base.ts src/widgets/shared/attribute-parser.ts src/widgets/shared/theme-manager.ts src/widgets/shared/responsive-manager.ts --skipLibCheck --moduleResolution node --target es2020 --module es2020` or equivalent check that the shared/ directory has no internal errors.
  </verify>
  <done>
WidgetBase extends HTMLElement with connectedCallback/disconnectedCallback/attributeChangedCallback lifecycle. Static observedAttributes includes all common data-attributes. ThemeManager and ResponsiveManager are wired in. getConfig() method provides backwards-compatible config object from attributes. Individual widgets will have expected compilation errors until migrated in Plans 02/03.
  </done>
</task>

</tasks>

<verification>
- All shared modules in src/widgets/shared/ compile without internal errors
- attribute-parser.ts exports 6 parsing functions
- theme-manager.ts exports ThemeManager class with applyTheme, listenForChanges, destroy methods
- responsive-manager.ts exports ResponsiveManager class with observe, disconnect methods
- widget-base.ts exports WidgetBase extending HTMLElement with Custom Element lifecycle
- Base styles include theme-aware CSS and container query setup
</verification>

<success_criteria>
- Shared infrastructure modules exist and compile cleanly
- WidgetBase is a proper Custom Element base class
- Theme system supports light/dark/auto with CSS custom properties
- Responsive system uses ResizeObserver with data-size attribute breakpoints
- Attribute parser handles all types safely (boolean, number, JSON, color, enum, CSS value)
</success_criteria>

<output>
After completion, create `.planning/phases/07-widget-attribute-system/07-01-SUMMARY.md`
</output>
