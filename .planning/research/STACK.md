# Technology Stack

**Project:** Strava Widgets — Interactive Mapping Features Milestone
**Researched:** 2026-02-16
**Confidence:** MEDIUM-HIGH

## Context

This research focuses on **stack additions for NEW interactive mapping features** in the subsequent v1.2 milestone. The v1.1 geographic statistics milestone is complete with offline-geocode-city (BEING REPLACED) and table widgets.

**NEW Capabilities Needed:**
1. Interactive route maps (individual run route visualization)
2. Heatmaps (density visualization of all run start points)
3. Country/city pin maps (markers with aggregated stats)
4. **Improved offline geocoding** (GeoNames-based, replacing offline-geocode-city)
5. Multi-city tracking via polyline decoding

**Validated Existing Stack (NO CHANGES):**
- TypeScript, Node.js 22, Chart.js 4.5.1, Vite 7.3.1 (IIFE bundles)
- Custom Elements, Shadow DOM, GitHub Actions CI/CD, GitHub Pages hosting
- 5 existing widgets deployed, 1,808 run activities with stored route polylines

---

## Recommended Stack Additions

### Core Mapping Library

| Technology | Version | Purpose | Why Recommended |
|------------|---------|---------|-----------------|
| Leaflet | ^1.9.4 | Interactive maps, route visualization, marker-based maps | Industry standard for DOM-based mapping. Lightweight (~40 KB gzipped), zero npm dependencies, extensive plugin ecosystem. Works with Vite IIFE bundles and Shadow DOM with proper configuration. |
| leaflet.heat | ^0.2.0 | Heatmap visualization layer | Official Leaflet plugin. Tiny (~2 KB), fast with grid-based clustering, handles 10,000+ points efficiently. Perfect for visualizing run density from start coordinates. |

**Rationale for Leaflet over MapLibre GL:**
- **Bundle size**: Leaflet 40 KB vs MapLibre GL 800 KB gzipped (~20x difference)
- **Feature fit**: DOM-based rendering sufficient for polyline routes and point heatmaps. No need for WebGL vector tiles, 3D terrain, or complex styling.
- **IIFE compatibility**: Leaflet bundles cleanly in Vite IIFE format. MapLibre's WebGL increases build complexity.
- **Shadow DOM integration**: Proven patterns exist for Shadow DOM (requires CSS injection workaround for marker icons).
- **Zero dependencies**: Leaflet has no npm dependencies. MapLibre requires vector tile infrastructure.
- **Tile provider flexibility**: Works with any raster tile provider (OpenStreetMap, Mapbox Static API, self-hosted).

**When MapLibre GL makes sense**: Vector tile rendering, 3D terrain, building extrusion, real-time style updates. NOT needed for run route polylines and heatmaps.

### Improved Offline Geocoding (REPLACEMENT)

| Technology | Version | Purpose | Why Recommended |
|------------|---------|---------|-----------------|
| offline-geocoder | ^1.0.2 | GeoNames-based offline reverse geocoding | **Replaces offline-geocode-city** (UN/LOCODE data returns suburbs, not cities). Uses GeoNames cities1000 dataset (12 MB SQLite). City-level accuracy, ~20,000+ cities worldwide, population ≥1,000 people. Node.js build-time geocoding (not browser runtime). |

**Migration from offline-geocode-city:**
| Current Issue | offline-geocoder Solution |
|---------------|---------------------------|
| Returns suburbs instead of cities | GeoNames cities1000 dataset provides accurate city names |
| UN/LOCODE data source (limited coverage) | GeoNames worldwide coverage (20,000+ cities) |
| 217 KB browser bundle overhead | 12 MB SQLite database used at BUILD TIME only (not bundled in widgets) |
| Geocoding in widget runtime | Pre-compute during compute-geo-stats, cache results in JSON |

**Why build-time only:**
- 12 MB SQLite database too large for browser bundle
- Widgets fetch pre-geocoded data from `data/geo/cities.json` (generated by compute-geo-stats)
- No runtime geocoding needed—all activities geocoded once during CI rebuild

**Alternative datasets:**
- cities500 (24 MB, pop ≥500) — more coverage
- cities5000 (8 MB, pop ≥5,000) — faster lookups
- cities15000 (4 MB, pop ≥15,000) — fastest, less coverage

Recommendation: cities1000 (default) balances coverage and accuracy for run tracking.

### Polyline Decoding

| Technology | Version | Purpose | Why Recommended |
|------------|---------|---------|-----------------|
| @mapbox/polyline | ^1.2.1 | Decode Strava summary_polyline to lat/lng coordinates | Most popular polyline library (270K+ weekly downloads vs 27K for @googlemaps/polyline-codec). Actively maintained (Google's library: no updates in 12+ months). Encodes/decodes GeoJSON, outputs [lat, lng] pairs compatible with Leaflet's L.polyline(). |

**Polyline Precision:**
- Strava uses precision factor 1e5 (100,000) ≈ 1.1m accuracy at equator
- @mapbox/polyline handles standard Google polyline encoding automatically
- Output format: `[[lat, lng], [lat, lng], ...]` — directly usable in Leaflet

**Build-time pattern:**
1. During compute-geo-stats, decode all summary_polyline fields
2. Store decoded coordinates in `data/routes/{activityId}.json`
3. Widgets fetch pre-decoded routes (no runtime polyline library needed)

**Why @mapbox/polyline over alternatives:**
- @googlemaps/polyline-codec: Inactive maintenance (no npm updates 12+ months)
- polyline (deprecated): Unmaintained, use @mapbox/polyline instead

### Supporting Libraries

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| vite-plugin-css-injected-by-js | ^3.5.1 | Inject Leaflet CSS into IIFE bundle | **REQUIRED** for IIFE format. Bundles CSS with JavaScript so widgets are single-file embeddable. Automatically injects Leaflet styles at runtime. Fixes Vite/Webpack marker icon path hashing issues. |
| @types/leaflet | ^1.9.14 | TypeScript type definitions for Leaflet | Development-time type safety for Leaflet API usage in widgets. |

---

## Installation

```bash
# Core mapping (widget runtime dependencies)
npm install leaflet@^1.9.4
npm install leaflet.heat@^0.2.0

# GeoNames geocoding (build-time only, Node.js)
npm install offline-geocoder@^1.0.2

# Polyline decoding (build-time only, Node.js)
npm install @mapbox/polyline@^1.2.1

# Dev dependencies (types + build tooling)
npm install -D @types/leaflet@^1.9.14
npm install -D vite-plugin-css-injected-by-js@^3.5.1
```

**REMOVE (after migration):**
```bash
npm uninstall offline-geocode-city
```

---

## Alternatives Considered

| Category | Recommended | Alternative | Why Not Alternative |
|----------|-------------|-------------|---------------------|
| **Mapping Library** | Leaflet | MapLibre GL JS | Bundle size: MapLibre 800 KB vs Leaflet 40 KB gzipped. WebGL overkill for route polylines and point heatmaps. Best for vector tiles, 3D terrain (not needed). Vite IIFE + Shadow DOM complexity. |
| **Mapping Library** | Leaflet | Google Maps API | Requires API key, usage pricing, online-only. Leaflet works offline with cached tiles. Proprietary vs open source. |
| **Mapping Library** | Leaflet | Mapbox GL JS v2+ | Proprietary license after v1.13 (Dec 2020). Non-OSS. Use MapLibre GL if you need WebGL. |
| **Heatmap** | leaflet.heat | heatmap.js + leaflet-heatmap plugin | leaflet.heat is official, simpler, faster for point-based heatmaps. heatmap.js better for custom gradients (not needed). ~10 KB larger. |
| **Geocoding** | offline-geocoder | local-reverse-geocoder | local-reverse-geocoder requires 2 GB download, 1.3 GB disk space. Offline-geocoder is 12 MB SQLite. Overkill for city-level accuracy. |
| **Geocoding** | offline-geocoder | Online APIs (Google, Nominatim) | Project requirement: offline geocoding in CI. No API calls from widgets. Nominatim has 1 req/sec rate limit (30 min for 1,808 activities). Offline-geocoder is instant. |
| **Geocoding** | offline-geocoder (GeoNames) | offline-geocode-city (UN/LOCODE) | Current library inaccurate (returns suburbs instead of cities). GeoNames dataset more accurate for city names. |
| **Polyline** | @mapbox/polyline | @googlemaps/polyline-codec | Google library inactive (no updates 12+ months). Mapbox library has 10x weekly downloads, active maintenance. |
| **Polyline** | @mapbox/polyline | polyline (npm) | Deprecated. No longer maintained. Use @mapbox/polyline. |

---

## What NOT to Use

| Avoid | Why | Use Instead |
|-------|-----|-------------|
| **Mapbox GL JS v2+** | Proprietary license after v1.13 (Dec 2020). Non-OSS. | Leaflet or MapLibre GL JS (OSS fork of Mapbox GL v1.13) |
| **offline-geocode-city** | Inaccurate (returns suburbs instead of cities). Uses UN/LOCODE data. Being replaced in this milestone. | offline-geocoder (GeoNames cities1000) |
| **polyline (npm)** | Deprecated. No longer maintained. | @mapbox/polyline |
| **Leaflet with default CSS imports in Vite** | Webpack/Vite bundlers break marker icon paths. CSS expects images at relative URLs but bundlers hash asset paths. | Manually import marker icons + use vite-plugin-css-injected-by-js |
| **Runtime polyline decoding in widgets** | Adds unnecessary bundle size (~5 KB). Decoding 1,808 routes at runtime is slow. | Pre-decode during build, store in JSON, widgets fetch pre-decoded routes |
| **Runtime geocoding in widgets** | offline-geocoder has 12 MB SQLite dependency (Node.js only). Cannot run in browser. | Pre-geocode during build (compute-geo-stats), widgets fetch cached results |

---

## Integration Patterns

### Pattern 1: Leaflet + Vite IIFE + Shadow DOM

**Challenge:**
1. Leaflet CSS references marker icon images via relative URLs (`url(images/marker-icon.png)`)
2. Vite hashes asset paths during build, breaking CSS references
3. Shadow DOM requires CSS to be injected into shadow root, not global document

**Solution:**

**Step 1: Install Vite CSS injection plugin**
```bash
npm install -D vite-plugin-css-injected-by-js
```

**Step 2: Configure vite.config.ts**
```typescript
import cssInjectedByJsPlugin from 'vite-plugin-css-injected-by-js'

export default defineConfig({
  plugins: [cssInjectedByJsPlugin()],
  build: {
    lib: {
      entry: './src/widgets/route-map-widget/index.ts',
      name: 'RouteMapWidget',
      formats: ['iife'],
      fileName: () => 'route-map.js'
    },
    rollupOptions: {
      output: {
        inlineDynamicImports: true // Bundle everything into single file
      }
    }
  }
})
```

**Step 3: Fix Leaflet marker icons in widget code**
```typescript
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';

// Import marker images directly (Vite will bundle them as base64 or assets)
import markerIcon from 'leaflet/dist/images/marker-icon.png';
import markerIcon2x from 'leaflet/dist/images/marker-icon-2x.png';
import markerShadow from 'leaflet/dist/images/marker-shadow.png';

// Fix default icon paths (required for Webpack/Vite bundlers)
delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
  iconUrl: markerIcon,
  iconRetinaUrl: markerIcon2x,
  shadowUrl: markerShadow,
});
```

**Step 4: Create map widget with Shadow DOM**
```typescript
class RouteMapWidget extends WidgetBase {
  private map: L.Map | null = null;

  connectedCallback() {
    super.connectedCallback(); // Sets up Shadow DOM

    // CSS automatically injected by vite-plugin-css-injected-by-js
    // Leaflet CSS now available in shadow root

    // Create map container div
    const mapContainer = document.createElement('div');
    mapContainer.id = 'map';
    mapContainer.style.width = '100%';
    mapContainer.style.height = '400px';
    this.shadowRoot!.appendChild(mapContainer);

    // Initialize Leaflet map
    this.map = L.map(mapContainer).setView([55.6761, 12.5683], 13);

    // Add OpenStreetMap tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(this.map);

    // Fetch and render route
    this.fetchAndRenderRoute();
  }

  async fetchAndRenderRoute() {
    const activityId = this.getAttribute('data-activity-id');
    const response = await fetch(`/data/routes/${activityId}.json`);
    const route = await response.json();

    // Add polyline to map
    const polyline = L.polyline(route.coordinates, {
      color: '#fc4c02',
      weight: 3,
      opacity: 0.8
    }).addTo(this.map!);

    // Fit map to route bounds
    this.map!.fitBounds(polyline.getBounds());
  }
}

customElements.define('route-map-widget', RouteMapWidget);
```

**Known Issue:** Leaflet has event retargeting problems with Shadow DOM on mobile (Android Chrome touch events, iOS click handlers not triggered). **Workaround:** Attach event listeners to Leaflet layer objects directly (e.g., `polyline.on('click', ...)`) instead of DOM elements.

**References:**
- [Leaflet Shadow DOM Issue #3246](https://github.com/Leaflet/Leaflet/issues/3246) — HIGH confidence
- [Leaflet Marker Icon Webpack Issue #7424](https://github.com/Leaflet/Leaflet/issues/7424) — HIGH confidence
- [Vite IIFE + Leaflet CSS Guide (MapTiler)](https://docs.maptiler.com/leaflet/examples/vite-vanilla-js-default/) — HIGH confidence

---

### Pattern 2: Polyline Decoding (Build-time)

**Goal:** Pre-decode all Strava summary_polyline fields during compute-geo-stats, store in JSON files.

**Implementation:**
```typescript
// src/geo/polyline-decoder.ts
import polyline from '@mapbox/polyline';
import type { StravaActivity } from '../types/strava.types.js';

interface DecodedRoute {
  activityId: number;
  coordinates: [number, number][]; // [[lat, lng], ...]
  bounds: {
    north: number;
    south: number;
    east: number;
    west: number;
  };
}

export function decodeActivityPolyline(activity: StravaActivity): DecodedRoute | null {
  if (!activity.map?.summary_polyline) {
    return null; // No route data (e.g., treadmill run)
  }

  try {
    const coords = polyline.decode(activity.map.summary_polyline);
    // coords format: [[lat, lng], [lat, lng], ...]

    // Calculate bounds for map fitting
    const lats = coords.map(c => c[0]);
    const lngs = coords.map(c => c[1]);

    return {
      activityId: activity.id,
      coordinates: coords,
      bounds: {
        north: Math.max(...lats),
        south: Math.min(...lats),
        east: Math.max(...lngs),
        west: Math.min(...lngs)
      }
    };
  } catch (error) {
    console.error(`Failed to decode polyline for activity ${activity.id}:`, error);
    return null;
  }
}
```

**Usage in compute-geo-stats:**
```typescript
// src/geo/compute-geo-stats.ts
import { decodeActivityPolyline } from './polyline-decoder.js';
import * as fs from 'fs/promises';
import * as path from 'path';

async function processRoutes(activities: StravaActivity[]) {
  const routesDir = 'data/routes';
  await fs.mkdir(routesDir, { recursive: true });

  for (const activity of activities) {
    const route = decodeActivityPolyline(activity);
    if (route) {
      const routePath = path.join(routesDir, `${activity.id}.json`);
      await fs.writeFile(routePath, JSON.stringify(route, null, 2));
    }
  }

  console.log(`Decoded ${activities.length} routes to ${routesDir}/`);
}
```

**Widget fetches pre-decoded routes:**
```typescript
// No polyline library in widget bundle
const response = await fetch(`/data/routes/${activityId}.json`);
const route = await response.json();
// route.coordinates is already [[lat, lng], ...]
L.polyline(route.coordinates).addTo(map);
```

**Benefits:**
- Zero polyline library overhead in widget bundles (~5 KB saved per widget)
- Instant route rendering (no decoding latency)
- Routes cached in GitHub Pages CDN

---

### Pattern 3: GeoNames Geocoding (Build-time)

**Goal:** Use offline-geocoder in compute-geo-stats script (Node.js only). Replace offline-geocode-city.

**Implementation:**
```typescript
// src/geo/geocoder.ts
import { geocode } from 'offline-geocoder';

interface GeoLocation {
  cityName: string;
  countryName: string;
  countryIso2: string;
}

export async function geocodeActivity(lat: number, lng: number): Promise<GeoLocation | null> {
  try {
    // offline-geocoder uses GeoNames cities1000 dataset (12 MB SQLite)
    const result = await geocode({
      latitude: lat,
      longitude: lng
    });

    if (!result || !result.city || !result.country) {
      return null; // Geocoding failed (e.g., ocean, remote area)
    }

    return {
      cityName: result.city || result.name,
      countryName: result.country,
      countryIso2: result.countryCode
    };
  } catch (error) {
    console.error('Geocoding failed:', error);
    return null;
  }
}
```

**Usage in compute-geo-stats:**
```typescript
// First run downloads GeoNames cities1000 dataset (12 MB SQLite)
// Subsequent runs use cached database

for (const activity of activities) {
  const [lat, lng] = activity.start_latlng;
  const location = await geocodeActivity(lat, lng);

  if (location) {
    // Aggregate by city/country
    cityMap.set(`${location.cityName},${location.countryIso2}`, {
      ...location,
      activityCount: (cityMap.get(key)?.activityCount || 0) + 1,
      totalDistanceKm: (cityMap.get(key)?.totalDistanceKm || 0) + activity.distance / 1000
    });
  }
}

// Write to data/geo/cities.json
await fs.writeFile('data/geo/cities.json', JSON.stringify([...cityMap.values()], null, 2));
```

**Widget fetches pre-geocoded data:**
```typescript
// No geocoding library in widget bundle
const response = await fetch('/data/geo/cities.json');
const cities = await response.json();
// cities already have { cityName, countryName, activityCount, totalDistanceKm }
```

**Migration from offline-geocode-city:**
1. Update `src/geo/geocoder.ts` to use offline-geocoder API
2. Run `npm run compute-geo-stats` to re-geocode all activities
3. Verify `data/geo/cities.json` has accurate city names (not suburbs)
4. Remove offline-geocode-city from dependencies
5. No widget changes needed (same JSON data format)

**Accuracy comparison:**
- offline-geocode-city: "Frederiksberg" (suburb) ❌
- offline-geocoder: "Copenhagen" (city) ✅

---

### Pattern 4: Heatmap Widget

**Goal:** Visualize density of all run start points using leaflet.heat.

**Implementation:**
```typescript
// src/widgets/heatmap-widget/index.ts
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import 'leaflet.heat';

class HeatmapWidget extends WidgetBase {
  private map: L.Map | null = null;

  async connectedCallback() {
    super.connectedCallback();

    // Create map container
    const mapContainer = document.createElement('div');
    mapContainer.style.width = '100%';
    mapContainer.style.height = '500px';
    this.shadowRoot!.appendChild(mapContainer);

    // Initialize map
    this.map = L.map(mapContainer).setView([55.6761, 12.5683], 11);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(this.map);

    // Fetch all activities and extract start coordinates
    const response = await fetch('/data/stats/all-activities.json');
    const activities = await response.json();

    const heatmapPoints = activities
      .filter((a: any) => a.start_latlng)
      .map((a: any) => {
        const [lat, lng] = a.start_latlng;
        return [lat, lng, 1]; // [lat, lng, intensity]
      });

    // Create heatmap layer
    (L as any).heatLayer(heatmapPoints, {
      radius: 25,
      blur: 15,
      maxZoom: 13,
      gradient: {
        0.0: '#313695',
        0.25: '#4575b4',
        0.5: '#fee090',
        0.75: '#f46d43',
        1.0: '#a50026'
      }
    }).addTo(this.map);
  }
}

customElements.define('heatmap-widget', HeatmapWidget);
```

**Customization via attributes:**
```html
<heatmap-widget
  data-radius="30"
  data-blur="20"
  data-center-lat="55.6761"
  data-center-lng="12.5683"
  data-zoom="11">
</heatmap-widget>
```

**Performance:** leaflet.heat uses grid-based clustering. Handles 10,000+ points efficiently (1,808 activities is no problem).

---

### Pattern 5: City Pin Map Widget

**Goal:** Show markers for each city with aggregated run stats.

**Implementation:**
```typescript
class CityPinMapWidget extends WidgetBase {
  private map: L.Map | null = null;

  async connectedCallback() {
    super.connectedCallback();

    // Create map
    const mapContainer = document.createElement('div');
    mapContainer.style.width = '100%';
    mapContainer.style.height = '600px';
    this.shadowRoot!.appendChild(mapContainer);

    this.map = L.map(mapContainer).setView([20, 0], 2); // World view

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(this.map);

    // Fetch city stats (pre-geocoded data)
    const response = await fetch('/data/geo/cities.json');
    const cities = await response.json();

    // Add marker for each city
    cities.forEach((city: any) => {
      // Need to reverse-lookup city coordinates (city name → lat/lng)
      // Two options:
      // 1. Store lat/lng in cities.json during compute-geo-stats
      // 2. Use offline-geocoder forward geocoding (city name → coords)

      // Option 1 (recommended): Add representative lat/lng to cities.json
      const marker = L.marker([city.lat, city.lng]).addTo(this.map!);

      marker.bindPopup(`
        <b>${city.cityName}, ${city.countryName}</b><br>
        Runs: ${city.activityCount}<br>
        Distance: ${city.totalDistanceKm.toFixed(1)} km
      `);
    });
  }
}
```

**Data structure update for cities.json:**
```json
[
  {
    "cityName": "Copenhagen",
    "countryName": "Denmark",
    "countryIso2": "DK",
    "activityCount": 450,
    "totalDistanceKm": 2340.5,
    "lat": 55.6761,
    "lng": 12.5683
  }
]
```

**Note:** Update compute-geo-stats to store representative lat/lng for each city (e.g., first activity's start_latlng in that city, or city center from GeoNames).

---

## Version Compatibility

| Package | Compatible With | Notes |
|---------|-----------------|-------|
| leaflet@1.9.4 | vite@7.x | Requires vite-plugin-css-injected-by-js for IIFE bundles. Works with Shadow DOM. |
| leaflet@1.9.4 | leaflet.heat@0.2.0 | No compatibility issues. leaflet.heat is stable since 2014. |
| leaflet@1.9.4 | TypeScript 5.9+ | Use @types/leaflet@^1.9.14 for type definitions. |
| @mapbox/polyline@1.x | Node.js 22+ | ESM compatible. Works in both Node and browser (but use build-time only). |
| offline-geocoder@1.0.2 | Node.js 22+ | Node.js only (SQLite dependency). Build-time geocoding. Not browser-compatible. |
| vite-plugin-css-injected-by-js@3.5.1 | vite@7.x | Injects CSS into IIFE bundles. Required for Leaflet marker icons to work. |

**Future Consideration:**
- Leaflet 2.0.0 alpha released (ESM-first, drops IE11, uses Pointer Events). Wait for stable release before upgrading.
- Current 1.9.4 is production-ready, widely used, well-documented.

---

## Bundle Size Impact

| Component | Size (gzipped) | Notes |
|-----------|----------------|-------|
| Leaflet core | ~40 KB | Base map functionality |
| leaflet.heat | ~2 KB | Heatmap layer plugin |
| Leaflet CSS (injected) | ~8 KB | Includes marker icon assets |
| Widget-specific code | ~5-10 KB | Route map, heatmap, pin map logic |
| **Total per map widget** | **~55-60 KB** | Acceptable for GitHub Pages CDN |

**Comparison:**
- MapLibre GL: ~800 KB gzipped (13x larger)
- Google Maps API: External script, ~500 KB + API key required

**Multi-widget optimization:**
If multiple map widgets on same page, Leaflet core can be shared. IIFE bundles will duplicate code by default. Consider UMD format + external Leaflet for advanced use cases (not recommended unless bundle size becomes critical).

**Build-time dependencies (NOT in widget bundles):**
- @mapbox/polyline: 0 KB (build-time only)
- offline-geocoder: 0 KB (build-time only)

---

## Stack Patterns by Feature

### Feature: Interactive Route Map

**Stack:**
- Leaflet (base map + route polyline)
- @mapbox/polyline (build-time decoding)
- OpenStreetMap tiles

**Data flow:**
1. Build-time: Decode summary_polyline → save to data/routes/{id}.json
2. Runtime: Widget fetches decoded route → L.polyline() → map.fitBounds()

**Bundle size:** ~55 KB gzipped

---

### Feature: Heatmap of Run Locations

**Stack:**
- Leaflet (base map)
- leaflet.heat (heatmap layer)

**Data flow:**
1. Widget fetches all activities from data/stats/all-activities.json
2. Extract start_latlng from each activity
3. Render with L.heatLayer(points)

**Bundle size:** ~57 KB gzipped (Leaflet + leaflet.heat)

---

### Feature: Country/City Pin Maps

**Stack:**
- Leaflet (base map + markers)
- offline-geocoder (build-time geocoding)

**Data flow:**
1. Build-time: Geocode activities → aggregate by city → save lat/lng to cities.json
2. Runtime: Widget fetches cities.json → L.marker() for each city → bindPopup() with stats

**Bundle size:** ~55 KB gzipped

---

### Feature: Multi-City Tracking Table

**Stack:**
- offline-geocoder (build-time geocoding)
- Existing geo-table-widget (no mapping library)

**Data flow:**
1. Build-time: Geocode activities, aggregate by city
2. Runtime: Render table with city stats (no map visualization)

**Bundle size:** Existing widget (no map dependencies)

---

## Tile Provider Configuration

| Provider | Cost | Tile URL | Notes |
|----------|------|----------|-------|
| OpenStreetMap | Free | `https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png` | Standard OSM tiles. Rate limits apply (tile usage policy). Attribution required. |
| Mapbox Static API | Free tier: 50K loads/mo | `https://api.mapbox.com/styles/v1/{style}/tiles/{z}/{x}/{y}?access_token={token}` | Requires API token. No vector tile complexity (raster tiles only). Better styling than OSM. |
| Stadia Maps | Free tier: 20K tiles/day | `https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png` | OSM-based tiles with better styling. Requires API key for production. |

**Recommendation:** Start with OpenStreetMap (zero config). Switch to Mapbox Static API if OSM rate limits become an issue or better styling is needed.

**Offline tiles:** For offline support, pre-download tiles using tools like `mbtiles-server`. Not needed for GitHub Pages (online deployment).

---

## Anti-Patterns to Avoid

### ❌ Using Leaflet default CSS import without fixing marker icons
**Why avoid:** Vite/Webpack hash asset paths, breaking CSS url() references. Markers won't display.
**Do instead:** Import marker icon PNGs directly, use L.Icon.Default.mergeOptions() to set paths.

### ❌ Runtime polyline decoding in widgets
**Why avoid:** Adds ~5 KB to bundle. Decoding 1,808 routes at runtime is slow (100ms+ on mobile).
**Do instead:** Pre-decode during build, store in JSON, widgets fetch pre-decoded routes.

### ❌ Runtime geocoding in widgets
**Why avoid:** offline-geocoder has 12 MB SQLite dependency (Node.js only). Cannot run in browser.
**Do instead:** Pre-geocode during build (compute-geo-stats), widgets fetch cached results.

### ❌ Using MapLibre GL for simple polyline routes
**Why avoid:** 800 KB bundle for features you don't need (vector tiles, 3D, advanced styling).
**Do instead:** Use Leaflet (40 KB) for DOM-based rendering. MapLibre only if you need WebGL features.

### ❌ Externalizing Leaflet in IIFE bundles without global variable
**Why avoid:** IIFE format requires global variables for externals. Complicates embedding.
**Do instead:** Bundle Leaflet in IIFE (40 KB is acceptable). Simpler deployment.

### ❌ Calling Nominatim API from widgets
**Why avoid:** 1 req/sec rate limit. Single point of failure. Requires internet. Adds latency.
**Do instead:** Pre-geocode in CI, cache results, widgets fetch static JSON.

---

## Dependency Summary

### NEW Production Dependencies
```json
{
  "dependencies": {
    "leaflet": "^1.9.4",
    "leaflet.heat": "^0.2.0",
    "offline-geocoder": "^1.0.2",
    "@mapbox/polyline": "^1.2.1"
  }
}
```

### NEW Dev Dependencies
```json
{
  "devDependencies": {
    "@types/leaflet": "^1.9.14",
    "vite-plugin-css-injected-by-js": "^3.5.1"
  }
}
```

### REMOVE (Replaced)
```json
{
  "dependencies": {
    "offline-geocode-city": "^1.0.2" // REMOVE after migration
  }
}
```

### NO CHANGES
- chart.js ^4.5.1 (existing widgets)
- bottleneck ^2.19.5 (existing)
- p-retry ^7.1.1 (existing)
- vite ^7.3.1 (existing)
- vitest ^4.0.18 (existing)

**Total NEW bundle size per map widget:** ~55-60 KB gzipped (Leaflet + leaflet.heat + widget code)

---

## Sources

**Mapping Libraries:**
- [Leaflet vs Mapbox comparison (Medium)](https://medium.com/visarsoft-blog/leaflet-or-mapbox-choosing-the-right-tool-for-interactive-maps-53dea7cc3c40) — MEDIUM confidence
- [MapLibre GL vs Leaflet (Jawg Blog)](https://blog.jawg.io/maplibre-gl-vs-leaflet-choosing-the-right-tool-for-your-interactive-map/) — HIGH confidence
- [Map libraries popularity (Geoapify)](https://www.geoapify.com/map-libraries-comparison-leaflet-vs-maplibre-gl-vs-openlayers-trends-and-statistics/) — MEDIUM confidence
- [Bundle size comparison (GitHub)](https://github.com/maplibre/maplibre-gl-js/issues/59) — HIGH confidence
- [Leaflet npm page](https://www.npmjs.com/package/leaflet) — HIGH confidence (version 1.9.4)

**Geocoding:**
- [offline-geocoder npm](https://www.npmjs.com/package/offline-geocoder) — HIGH confidence
- [offline-geocoder GitHub](https://github.com/lucaspiller/offline-geocoder) — HIGH confidence
- [local-reverse-geocoder comparison](https://github.com/tomayac/local-reverse-geocoder) — MEDIUM confidence

**Polyline:**
- [@mapbox/polyline vs @googlemaps/polyline-codec (npm trends)](https://npmtrends.com/@googlemaps/polyline-codec-vs-@mapbox/polyline) — HIGH confidence
- [@mapbox/polyline GitHub](https://github.com/mapbox/polyline) — HIGH confidence
- [Strava polyline precision (GitHub)](https://github.com/grafana/strava-datasource/blob/master/src/polyline.ts) — MEDIUM confidence

**Heatmaps:**
- [Leaflet.heat GitHub](https://github.com/Leaflet/Leaflet.heat) — HIGH confidence
- [Leaflet.heat demo](https://leaflet.github.io/Leaflet.heat/demo/) — HIGH confidence
- [Leaflet.heat npm](https://www.npmjs.com/package/leaflet.heat) — HIGH confidence (version 0.2.0)

**Integration:**
- [Leaflet Shadow DOM issue #3246](https://github.com/Leaflet/Leaflet/issues/3246) — HIGH confidence
- [Leaflet marker icon bundling issue #7424](https://github.com/Leaflet/Leaflet/issues/7424) — HIGH confidence
- [Vite IIFE + Leaflet CSS (MapTiler)](https://docs.maptiler.com/leaflet/examples/vite-vanilla-js-default/) — HIGH confidence
- [Vite CSS injection plugin](https://www.npmjs.com/package/vite-plugin-css-injected-by-js) — HIGH confidence

**MapLibre GL (Alternative):**
- [MapLibre GL official site](https://maplibre.org/) — HIGH confidence
- [MapLibre vs Mapbox (MapTiler)](https://www.maptiler.com/news/2021/01/maplibre-mapbox-gl-open-source-fork/) — MEDIUM confidence

---

**Research completed:** 2026-02-16
**Confidence:** MEDIUM-HIGH (Web Search sources authoritative; exact npm versions not verified via Context7 due to access limitations)
**Next step:** Create FEATURES.md, ARCHITECTURE.md, PITFALLS.md, SUMMARY.md for mapping milestone
