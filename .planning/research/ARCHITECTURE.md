# Architecture Research: Geographic Data Integration

**Domain:** Strava Analytics Platform - Geographic Data & Widget Customization Extension
**Researched:** 2026-02-14
**Confidence:** HIGH
**Milestone Context:** Subsequent milestone adding geographic features to existing platform

## Integration Architecture Overview

This milestone adds four new capabilities to the existing Strava analytics platform:
1. **Geographic data extraction** (reverse geocoding)
2. **Geographic statistics computation**
3. **Table/list widget rendering**
4. **Widget customization via HTML attributes**

### System Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    FRONTEND (GitHub Pages)                   │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐        │
│  │ Stats   │  │Compari- │  │ Streak  │  │  NEW:   │        │
│  │ Card    │  │son Chart│  │ Widget  │  │Geographic│       │
│  │ Widget  │  │ Widget  │  │         │  │  Table   │       │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘        │
│       │            │            │            │              │
│       └────────────┴────────────┴────────────┘              │
│                      │                                       │
│              Shadow DOM Isolation                            │
│              + Attribute Config (NEW)                        │
├─────────────────────────────────────────────────────────────┤
│                   STATIC JSON DATA                           │
├─────────────────────────────────────────────────────────────┤
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │ Existing Stats   │  │  NEW: Geographic │                │
│  │ - weekly.json    │  │  - geo-stats.json│                │
│  │ - monthly.json   │  │  - locations.json│                │
│  │ - yearly.json    │  └──────────────────┘                │
│  │ - all-time.json  │                                       │
│  │ - streaks.json   │                                       │
│  └──────────────────┘                                       │
└─────────────────────────────────────────────────────────────┘
                          ↑
                     (generated by)
                          ↓
┌─────────────────────────────────────────────────────────────┐
│               DATA PIPELINE (Node.js 22)                     │
├─────────────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────────────┐  │
│  │              Activity Sync Layer                       │  │
│  │  ┌──────────┐ → ┌──────────┐ → ┌──────────┐          │  │
│  │  │  Strava  │   │  OAuth   │   │   File   │          │  │
│  │  │  Client  │   │  Manager │   │  Storage │          │  │
│  │  └──────────┘   └──────────┘   └──────────┘          │  │
│  └───────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌───────────────────────────────────────────────────────┐  │
│  │         NEW: Geographic Enrichment Layer              │  │
│  │  ┌──────────────┐ → ┌──────────────┐                 │  │
│  │  │   Reverse    │   │  Location    │                 │  │
│  │  │  Geocoder    │   │    Cache     │                 │  │
│  │  │  Service     │   │  (JSON file) │                 │  │
│  │  └──────────────┘   └──────────────┘                 │  │
│  │       ↑                                                │  │
│  │       └── Rate limited (1 req/sec max)                │  │
│  └───────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌───────────────────────────────────────────────────────┐  │
│  │            Statistics Computation Layer                │  │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐              │  │
│  │  │ Basic    │ │ Advanced │ │   NEW:   │              │  │
│  │  │ Stats    │ │  Stats   │ │Geographic│              │  │
│  │  │ Compute  │ │ Compute  │ │  Stats   │              │  │
│  │  └──────────┘ └──────────┘ └──────────┘              │  │
│  └───────────────────────────────────────────────────────┘  │
│                          ↓                                   │
│  ┌───────────────────────────────────────────────────────┐  │
│  │               JSON Output Layer                        │  │
│  │  ┌──────────────────────────────────────────────────┐ │  │
│  │  │  data/                                           │ │  │
│  │  │  ├── activities/ (raw Strava JSON)               │ │  │
│  │  │  ├── stats/ (computed statistics)                │ │  │
│  │  │  └── NEW: geo/ (cached locations + geo-stats)    │ │  │
│  │  └──────────────────────────────────────────────────┘ │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                          ↑
                   (triggered daily by)
                          ↓
┌─────────────────────────────────────────────────────────────┐
│               GITHUB ACTIONS (CI/CD)                         │
│  Daily cron: sync → geocode → compute-stats → deploy        │
└─────────────────────────────────────────────────────────────┘
```

## New Components

### 1. Reverse Geocoding Service

**Location:** `src/services/reverse-geocoder.ts`

**Purpose:** Converts lat/lng coordinates to human-readable locations (city, country)

**Responsibilities:**
- Accept `[lat, lng]` coordinates from activity data
- Query reverse geocoding API with rate limiting
- Handle API failures gracefully (return null on error)
- Transform API response to standardized location format
- Respect 1 req/sec rate limit (Nominatim)

**Recommended Provider:** Nominatim (OpenStreetMap)
- **Why:** Free, no API key required, permissive caching
- **Rate limit:** 1 request/second
- **Cost:** Free (donations appreciated)
- **Caching:** Unlimited duration allowed
- **Attribution:** Required in UI

**Alternative if Nominatim blocked:** LocationIQ (5,000 req/day free, requires API key)

**Interface:**
```typescript
export interface GeocodeResult {
  city: string | null;
  country: string;
  countryCode: string;  // ISO 3166-1 alpha-2
  displayName: string;  // "Lisbon, Portugal"
}

export interface ReverseGeocoderConfig {
  provider: 'nominatim' | 'locationiq';
  apiKey?: string;  // Only for LocationIQ
  rateLimit: number;  // requests per second
  timeout: number;    // milliseconds
  userAgent: string;  // Required for Nominatim
}

export class ReverseGeocoder {
  async geocode(lat: number, lng: number): Promise<GeocodeResult | null>;
  async geocodeBatch(coords: [number, number][]): Promise<(GeocodeResult | null)[]>;
}
```

**Implementation notes:**
- Use `bottleneck` (already in dependencies) for rate limiting
- Set User-Agent header: `"StravaAnalytics/1.0 (your-email@example.com)"`
- Cache results in JSON file (see Location Cache below)
- Fail gracefully: if API errors, return `null` and continue

**Sources:**
- [Nominatim Usage Policy](https://operations.osmfoundation.org/policies/nominatim/)
- [Public APIs - Free Geocoding APIs 2026](https://publicapis.io/blog/free-geocoding-apis)

### 2. Location Cache

**Location:** `data/geo/location-cache.json`

**Purpose:** Permanent storage of geocoded locations to minimize API calls

**Format:**
```json
{
  "38.76,-9.12": {
    "city": "Lisbon",
    "country": "Portugal",
    "countryCode": "PT",
    "displayName": "Lisbon, Portugal",
    "geocodedAt": "2026-02-14T10:00:00Z"
  }
}
```

**Key format:** `"{lat},{lng}"` rounded to 2 decimal places (~1km precision)

**Rationale:**
- Activities starting in same area share coordinates
- 2 decimal precision = sufficient for city-level accuracy
- Unlimited caching allowed by Nominatim
- Git-tracked for persistence across runs

**Cache hit rate:** Expected >90% after initial geocoding (most runs start from home/common locations)

**Sources:**
- [Caching Geocoding Results - AddressHub](https://address-hub.com/address-intelligence/caching/)
- [Sanborn - Optimizing Google Maps Geocoding](https://sanborn.com/blog/optimizing-google-maps-geocoding-api-at-scale-balancing-cost-and-performance/)

### 3. Geographic Statistics Computation

**Location:** `src/analytics/compute-geo-stats.ts`

**Purpose:** Aggregate activities by geographic location

**Process:**
1. Read all activities with `start_latlng`
2. Lookup location from cache (or geocode if missing)
3. Group by country/city
4. Compute aggregates per location

**Output:** `data/stats/geo-stats.json`

**Format:**
```json
{
  "byCountry": [
    {
      "country": "Portugal",
      "countryCode": "PT",
      "totalKm": 1234.5,
      "runCount": 145,
      "percentage": 65.2,
      "cities": ["Lisbon", "Porto"]
    }
  ],
  "byCity": [
    {
      "city": "Lisbon",
      "country": "Portugal",
      "totalKm": 987.3,
      "runCount": 112,
      "percentage": 50.4
    }
  ],
  "metadata": {
    "generatedAt": "2026-02-14T10:00:00Z",
    "totalActivities": 222,
    "activitiesWithLocation": 215,
    "uniqueCountries": 3,
    "uniqueCities": 8
  }
}
```

**Integration:** Called after `compute-advanced-stats` in pipeline

### 4. Geographic Table Widget

**Location:** `src/widgets/geo-table/index.ts`

**Purpose:** Display geographic statistics as sortable HTML table in Shadow DOM

**Features:**
- Table rows for countries/cities
- Columns: Location, Distance, Runs, Percentage
- Sortable columns (click header to sort)
- Responsive layout
- Shadow DOM isolation
- Attribute-based customization

**Build:** Separate Vite IIFE entry point in `scripts/build-widgets.mjs`

**Example HTML usage:**
```html
<div id="geo-widget"
     data-url="https://example.github.io/data/stats/geo-stats.json"
     data-group-by="country"
     data-sort-by="totalKm"
     data-show-title="true"
     data-custom-title="Running Locations"
     data-accent-color="#fc4c02">
</div>
<script src="dist/widgets/geo-table.iife.js"></script>
<script>
  GeoTable.init('geo-widget');
</script>
```

**Implementation:** Extends `WidgetBase` with table-specific rendering

### 5. Widget Attribute Configuration System

**Purpose:** Allow widget customization via HTML data attributes with defaults

**Pattern:** Read attributes → parse with defaults → apply to widget config

**Standard Attributes (all widgets):**
- `data-url` (required): JSON data source URL
- `data-accent-color` (optional): Brand color (default: `#fc4c02`)
- `data-bg-color` (optional): Background (default: `#ffffff`)
- `data-text-color` (optional): Text color (default: `#333333`)
- `data-show-title` (optional): Show title (default: `true`)
- `data-custom-title` (optional): Override title text

**Widget-specific Attributes:**
- GeoTable: `data-group-by`, `data-sort-by`, `data-max-rows`
- Charts: `data-time-range`, `data-chart-type`

**Implementation Location:** Extend `WidgetBase` with attribute parsing

**Code pattern:**
```typescript
export abstract class WidgetBase<T = unknown> {
  protected parseAttributes(container: HTMLElement): WidgetConfig {
    return {
      dataUrl: container.dataset.url || '',
      colors: {
        accent: container.dataset.accentColor || '#fc4c02',
        background: container.dataset.bgColor || '#ffffff',
        text: container.dataset.textColor || '#333333',
      },
      options: {
        showTitle: container.dataset.showTitle !== 'false',
        customTitle: container.dataset.customTitle,
        ...this.parseWidgetSpecificAttributes(container)
      }
    };
  }

  protected abstract parseWidgetSpecificAttributes(container: HTMLElement): Record<string, any>;
}
```

**Rationale:**
- Uses standard HTML `data-*` attributes (best practice)
- Browser automatically populates `dataset` property
- No manual `getAttribute()` calls needed
- Type-safe defaults in code
- User overrides via HTML

**Sources:**
- [MDN: Using data attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/How_to/Use_data_attributes)
- [Open Web Components: Attributes and Properties](https://open-wc.org/guides/knowledge/attributes-and-properties/)
- [Web.dev: Custom Elements Best Practices](https://web.dev/articles/custom-elements-best-practices)

## Modified Components

### 1. Data Pipeline CLI (`src/index.ts`)

**Changes:**
- Add new command: `geocode-activities`
- Add new command: `compute-geo-stats`
- Update `compute-all-stats` to include geographic stats

**New commands:**
```bash
npm run geocode          # Geocode all activities with coordinates
npm run compute-geo      # Compute geographic statistics
npm run compute-all-stats # Now includes geographic stats
```

### 2. Widget Base Class (`src/widgets/shared/widget-base.ts`)

**Changes:**
- Add `parseAttributes()` method to read HTML data attributes
- Modify constructor to call `parseAttributes()` instead of accepting config object
- Add `parseWidgetSpecificAttributes()` abstract method for subclasses
- Update `createShadowRoot()` to handle attribute-based config

**Breaking change:** Widget initialization changes from config object to attribute-based

**Migration:**
```typescript
// OLD (config object passed)
new StatsCardWidget('container', {
  dataUrl: 'data.json',
  colors: { accent: '#fc4c02' }
});

// NEW (attributes read from DOM)
// HTML: <div id="container" data-url="data.json" data-accent-color="#fc4c02"></div>
new StatsCardWidget('container');
```

### 3. Widget Build Script (`scripts/build-widgets.mjs`)

**Changes:**
- Add geo-table widget to build list
- No other changes needed (already supports multiple entry points)

**New entry:**
```javascript
{
  name: 'geo-table',
  entry: resolve(__dirname, '../src/widgets/geo-table/index.ts'),
  globalName: 'GeoTable'
}
```

### 4. Strava Activity Types (`src/types/strava.types.ts`)

**Changes:**
- Add JSDoc comment documenting that `start_latlng` may be `undefined`
- No interface changes (already optional with `?`)

### 5. GitHub Actions Workflow (`.github/workflows/daily-refresh.yml`)

**Changes:**
- Add geocoding step before stats computation
- Add error handling for geocoding failures (non-blocking)

**New workflow:**
```yaml
- name: Geocode activities
  run: npm run geocode
  continue-on-error: true  # Don't fail if geocoding service down

- name: Compute all statistics
  run: npm run compute-all-stats  # Now includes geo stats
```

## Data Flow

### Geographic Data Enrichment Flow

```
Activity Sync (existing)
    ↓
Read activities with start_latlng
    ↓
For each unique coordinate:
    ├─ Check location-cache.json
    ├─ If cached → use cached result
    └─ If not cached:
        ├─ Rate limit (wait if needed)
        ├─ Call Nominatim API
        ├─ Parse response
        ├─ Save to cache
        └─ Continue
    ↓
Compute geographic statistics
    ↓
Write geo-stats.json
    ↓
Deploy to GitHub Pages
    ↓
Widget fetches geo-stats.json
    ↓
Render table in Shadow DOM
```

### Widget Attribute Configuration Flow

```
Browser loads page with widget HTML
    ↓
Widget script executes (IIFE)
    ↓
Widget.init('container-id') called
    ↓
Find container element by ID
    ↓
Read dataset attributes
    ├─ data-url → config.dataUrl
    ├─ data-accent-color → config.colors.accent
    ├─ data-show-title → config.options.showTitle
    └─ ... (all attributes)
    ↓
Apply defaults for missing attributes
    ↓
Create Shadow DOM
    ↓
Apply CSS custom properties from config
    ↓
Fetch data from dataUrl
    ↓
Render widget content
```

## Integration Points

### 1. Activity Sync → Geocoding

**Integration:** After activity sync completes, geocoding step runs

**Data dependency:** `start_latlng` field in activity JSON

**Error handling:**
- Activities without `start_latlng` → skipped (no error)
- API failure → logged, cached as `null`, computation continues
- Rate limit hit → wait, retry with exponential backoff

**Performance:**
- Initial run: ~200 activities × 1 req/sec = ~3 minutes
- Subsequent runs: Only new activities need geocoding (~5-10 activities/week)
- Cache hit rate: >90% after first run

### 2. Geocoding → Statistics Computation

**Integration:** Geographic stats computation reads location cache

**Data dependency:** `data/geo/location-cache.json`

**Behavior:**
- Activities with cached location → included in stats
- Activities without location → counted in metadata, excluded from aggregates

### 3. Statistics Computation → Widget

**Integration:** Widget fetches JSON via HTTP (same as existing widgets)

**Data dependency:** `data/stats/geo-stats.json` served via GitHub Pages

**Error handling:** Widget shows "Widget unavailable" if fetch fails

### 4. HTML → Widget Configuration

**Integration:** Widgets read configuration from HTML data attributes

**Data dependency:** Container element must exist before widget initialization

**Error handling:** Missing required attributes → console error, widget fails to initialize

## Build Order (Suggested)

### Phase 1: Geocoding Infrastructure
**Why first:** Foundation for all geographic features

1. **Reverse Geocoder Service**
   - `src/services/reverse-geocoder.ts`
   - `src/types/geo.types.ts`
   - Tests for rate limiting, error handling

2. **Location Cache**
   - `data/geo/location-cache.json` (initially empty)
   - File I/O functions in geocoder service

3. **Geocoding CLI Command**
   - Add `geocode-activities` command to `src/index.ts`
   - Read activities, geocode unique coordinates, update cache

**Validation:** Run geocoding on local activities, verify cache populated

### Phase 2: Geographic Statistics
**Why second:** Depends on geocoded data, needed for widget

4. **Geographic Stats Computation**
   - `src/analytics/compute-geo-stats.ts`
   - Reads activities + location cache
   - Outputs `data/stats/geo-stats.json`

5. **CLI Integration**
   - Add `compute-geo-stats` command
   - Update `compute-all-stats` to call geo stats

**Validation:** Run stats computation, verify geo-stats.json format

### Phase 3: Widget Attribute System
**Why third:** Foundation for new widget + existing widget improvements

6. **Widget Base Refactor**
   - Modify `WidgetBase` to parse HTML attributes
   - Add `parseAttributes()` method
   - Add abstract `parseWidgetSpecificAttributes()`
   - Update constructor signature

7. **Existing Widget Migration**
   - Update `StatsCardWidget` to use attributes
   - Update `ComparisonChart` to use attributes
   - Update `StreakWidget` to use attributes
   - Update documentation/examples

**Validation:** Test existing widgets with new attribute-based config

### Phase 4: Geographic Table Widget
**Why last:** Depends on all previous components

8. **Geographic Table Widget**
   - `src/widgets/geo-table/index.ts`
   - Table rendering logic
   - Sorting functionality
   - Responsive CSS

9. **Build Configuration**
   - Add geo-table to `scripts/build-widgets.mjs`
   - Build and test IIFE bundle

10. **Widget Demo Page**
    - Create demo HTML page
    - Test all attribute combinations

**Validation:** Widget renders correctly, sorting works, responsive layout

### Phase 5: CI/CD Integration
**Why final:** Integrates all components into automated workflow

11. **GitHub Actions Update**
    - Add geocoding step to workflow
    - Update stats computation step
    - Add error handling

12. **Documentation**
    - Update README with new commands
    - Document widget attributes
    - Add geocoding attribution requirements

**Validation:** Full pipeline runs on GitHub Actions, deploys successfully

## Dependency Graph

```
Phase 1: Geocoding Infrastructure
    ↓
Phase 2: Geographic Statistics (depends on Phase 1)
    ↓
Phase 3: Widget Attribute System (independent of Phase 1-2)
    ↓
Phase 4: Geographic Table Widget (depends on Phase 2 + Phase 3)
    ↓
Phase 5: CI/CD Integration (depends on all phases)
```

**Parallel work opportunities:**
- Phase 1 and Phase 3 can be developed in parallel (independent)
- Testing can happen incrementally after each phase

## Architectural Patterns

### Pattern 1: Rate-Limited External API Integration

**What:** Integrate external API with strict rate limits into batch processing pipeline

**When to use:** Any external API with rate limits (geocoding, enrichment services)

**Implementation:**
```typescript
import Bottleneck from 'bottleneck';

const limiter = new Bottleneck({
  minTime: 1000,  // 1 request per second
  maxConcurrent: 1
});

export class ReverseGeocoder {
  async geocode(lat: number, lng: number): Promise<GeocodeResult | null> {
    return limiter.schedule(() => this.callAPI(lat, lng));
  }

  private async callAPI(lat: number, lng: number): Promise<GeocodeResult | null> {
    try {
      const response = await fetch(`https://nominatim.org/reverse?lat=${lat}&lon=${lng}`);
      return this.parseResponse(response);
    } catch (error) {
      console.error('Geocoding failed:', error);
      return null;  // Fail gracefully
    }
  }
}
```

**Trade-offs:**
- Pro: Respects API limits, avoids bans
- Pro: Automatic queuing and retry
- Con: Slow for initial bulk processing (mitigated by caching)

### Pattern 2: Persistent JSON Cache

**What:** Cache API responses in git-tracked JSON files

**When to use:** API responses that rarely change (locations, metadata)

**Implementation:**
```typescript
export class LocationCache {
  private cache: Map<string, GeocodeResult>;
  private cacheFile = 'data/geo/location-cache.json';

  async load(): Promise<void> {
    const data = await fs.readFile(this.cacheFile, 'utf-8');
    this.cache = new Map(Object.entries(JSON.parse(data)));
  }

  async save(): Promise<void> {
    const obj = Object.fromEntries(this.cache);
    await fs.writeFile(this.cacheFile, JSON.stringify(obj, null, 2));
  }

  get(lat: number, lng: number): GeocodeResult | null {
    const key = `${lat.toFixed(2)},${lng.toFixed(2)}`;
    return this.cache.get(key) || null;
  }

  set(lat: number, lng: number, result: GeocodeResult): void {
    const key = `${lat.toFixed(2)},${lng.toFixed(2)}`;
    this.cache.set(key, result);
  }
}
```

**Trade-offs:**
- Pro: Free, unlimited caching (within git repo size limits)
- Pro: Survives across runs, deployments, CI rebuilds
- Pro: Git-tracked, auditable, reversible
- Con: Cache file grows over time (acceptable for location data)
- Con: Merge conflicts if multiple users (unlikely for personal project)

### Pattern 3: Shadow DOM Widget with Attribute Configuration

**What:** Web component using Shadow DOM + HTML data attributes for configuration

**When to use:** Embeddable widgets for third-party sites

**Implementation:**
```typescript
export class GeoTableWidget extends WidgetBase<GeoStats> {
  constructor(containerId: string) {
    super(containerId);
  }

  protected parseWidgetSpecificAttributes(container: HTMLElement): Record<string, any> {
    return {
      groupBy: container.dataset.groupBy || 'country',
      sortBy: container.dataset.sortBy || 'totalKm',
      maxRows: parseInt(container.dataset.maxRows || '10', 10)
    };
  }

  protected render(data: GeoStats): void {
    const table = document.createElement('table');
    // Render table from data
    this.shadowRoot?.appendChild(table);
  }
}
```

**HTML usage:**
```html
<div id="widget"
     data-url="geo-stats.json"
     data-group-by="city"
     data-sort-by="runCount"></div>
<script src="geo-table.iife.js"></script>
<script>GeoTable.init('widget');</script>
```

**Trade-offs:**
- Pro: No JavaScript config object needed (HTML-only config)
- Pro: Easy for non-developers to customize
- Pro: Type-safe defaults in code
- Con: All values are strings (need parsing for numbers/booleans)

**Sources:**
- [MDN: Using Custom Elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements)
- [Smashing Magazine: Web Components and Shadow DOM](https://www.smashingmagazine.com/2025/07/web-components-working-with-shadow-dom/)

### Pattern 4: Git-Tracked Static Site Generation

**What:** Pre-compute all data as static JSON, commit to git, serve via GitHub Pages

**When to use:** Analytics dashboards, personal data projects

**Current implementation:** Already used for weekly/monthly stats

**Extension for geographic data:**
- Same pattern: compute → write JSON → commit → deploy
- New files: `data/geo/location-cache.json`, `data/stats/geo-stats.json`

**Trade-offs:**
- Pro: Zero backend infrastructure cost
- Pro: Fast widget loading (static files)
- Pro: Works with GitHub Pages free tier
- Con: Git repo size grows (mitigated by small JSON files)
- Con: Rebuild needed for updates (acceptable for daily cron)

## Anti-Patterns

### Anti-Pattern 1: Client-Side Geocoding

**What people do:** Call reverse geocoding API from browser in widget

**Why it's wrong:**
- Exposes API keys in client code
- Hits rate limits quickly (every page load)
- Can't cache results (no persistence in browser)
- Slow widget loading

**Do this instead:**
- Geocode during build/CI pipeline
- Cache results in static JSON
- Widgets fetch pre-geocoded data

### Anti-Pattern 2: Inline Widget Configuration

**What people do:**
```javascript
new GeoTable('container', {
  dataUrl: 'data.json',
  groupBy: 'country',
  sortBy: 'totalKm'
  // ... 20 more config options
});
```

**Why it's wrong:**
- Non-developers can't customize (requires JS knowledge)
- Config scattered across HTML + JS files
- Hard to override defaults
- Not declarative

**Do this instead:**
```html
<div id="container"
     data-url="data.json"
     data-group-by="country"
     data-sort-by="totalKm"></div>
<script>GeoTable.init('container');</script>
```

**Benefits:**
- Single source of truth (HTML)
- Easy to customize without touching JS
- Declarative configuration
- Framework-agnostic

### Anti-Pattern 3: Custom Attribute Names (Without data- Prefix)

**What people do:**
```html
<div id="widget" url="data.json" group-by="country"></div>
```

**Why it's wrong:**
- Violates HTML spec (custom attributes require `data-` prefix)
- Won't populate `dataset` property automatically
- May conflict with future HTML standards
- Fails validation

**Do this instead:**
```html
<div id="widget" data-url="data.json" data-group-by="country"></div>
```

Access via `element.dataset.url`, `element.dataset.groupBy`

**Sources:**
- [MDN: HTML Attribute Reference](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes)

### Anti-Pattern 4: Synchronous Geocoding in Stats Computation

**What people do:**
```typescript
for (const activity of activities) {
  const location = await geocode(activity.start_latlng);  // Waits sequentially
  stats[location.country] += activity.distance;
}
```

**Why it's wrong:**
- 200 activities × 1 second = 3+ minutes (serial processing)
- Geocoding failure blocks stats computation
- Can't separate geocoding from stats (tight coupling)

**Do this instead:**
```typescript
// Step 1: Geocode (separate command, runs once)
await geocodeAllActivities();  // Populates cache

// Step 2: Compute stats (reads from cache)
for (const activity of activities) {
  const location = cache.get(activity.start_latlng);  // Instant
  if (location) {
    stats[location.country] += activity.distance;
  }
}
```

**Benefits:**
- Geocoding and stats are independent
- Stats computation is fast (no API calls)
- Geocoding failures don't break stats
- Can re-compute stats without re-geocoding

## Scaling Considerations

| Scale | Architecture Adjustments |
|-------|--------------------------|
| 1-500 activities | Current architecture sufficient. Geocoding takes ~5 minutes initially, <10 seconds for incremental updates. |
| 500-2000 activities | Consider batching geocoding in parallel with multiple API keys (LocationIQ free tier supports this). Cache hit rate >95%. |
| 2000+ activities | Migrate to paid geocoding service with higher rate limits, or self-host Nominatim instance for unlimited requests. |

### Scaling Priorities

1. **First bottleneck:** Geocoding rate limits (1 req/sec)
   - **Fix:** Use LocationIQ free tier (5,000 req/day = 3.5 req/sec effective)
   - **Cost:** Free
   - **Effort:** Add `apiKey` config, change API endpoint

2. **Second bottleneck:** Git repo size (location cache grows)
   - **When:** ~10,000 unique locations (~5MB JSON)
   - **Fix:** Switch to external storage (GitHub Gist, R2, etc.)
   - **Cost:** Free (Gist) or ~$0.01/month (R2)
   - **Effort:** Modify cache to fetch from external URL

3. **Third bottleneck:** GitHub Actions minutes (geocoding takes too long)
   - **When:** >1000 new activities/month
   - **Fix:** Move geocoding to separate scheduled job, run less frequently
   - **Cost:** Free (still within GitHub Actions limits)
   - **Effort:** Split workflow into sync + geocode jobs

**Current project scale:** ~200 activities, growing ~10/week
**Estimated time to first bottleneck:** 50+ weeks (plenty of runway)

## Technology Choices

### Reverse Geocoding: Nominatim (OpenStreetMap)

**Chosen:** Nominatim
**Alternatives considered:** LocationIQ, OpenCage, Google Maps

**Why Nominatim:**
- Free, no API key required (lowest friction)
- Unlimited caching allowed (critical for git-tracked approach)
- 1 req/sec sufficient for incremental updates
- Open source, community-supported
- Attribution requirement acceptable

**When to switch to LocationIQ:**
- Initial geocoding of large backlog (>500 activities)
- Nominatim service unreliable
- Need faster rate limits

**When to switch to paid service:**
- >2000 activities
- Need SLA guarantees
- Commercial use

### Widget Configuration: HTML data- Attributes

**Chosen:** HTML `data-*` attributes
**Alternatives considered:** JavaScript config object, Custom attributes, JSON config file

**Why data- attributes:**
- Standard HTML pattern (MDN recommended)
- Automatic `dataset` property population
- Declarative (configuration visible in HTML)
- Easy for non-developers
- Framework-agnostic

**Trade-offs accepted:**
- All values are strings (need parsing)
- Verbose for complex config (acceptable for simple widgets)

### Widget Rendering: Vanilla JS + Shadow DOM

**Chosen:** Continue with vanilla JS + Shadow DOM
**Alternatives considered:** Web Components v1, Lit, Svelte

**Why vanilla JS:**
- Already established in project
- Zero dependencies (smallest bundle size)
- Shadow DOM provides sufficient isolation
- Simple enough for table rendering

**When to switch to framework:**
- Complex interactions (drag-drop, filtering)
- State management needs
- Reusable component library

## Sources

**Reverse Geocoding:**
- [Nominatim Usage Policy](https://operations.osmfoundation.org/policies/nominatim/)
- [Public APIs - Free Geocoding APIs 2026](https://publicapis.io/blog/free-geocoding-apis)
- [Mapscaping - Geocoding API Pricing Guide](https://mapscaping.com/guide-to-geocoding-api-pricing/)
- [OpenCage Geocoding Pricing](https://opencagedata.com/pricing)

**Caching Best Practices:**
- [AddressHub - Caching Geocoding Results](https://address-hub.com/address-intelligence/caching/)
- [Sanborn - Optimizing Google Maps Geocoding](https://sanborn.com/blog/optimizing-google-maps-geocoding-api-at-scale-balancing-cost-and-performance/)
- [Google - Optimizing Quota Usage](https://developers.google.com/maps/documentation/geocoding/geocoding-strategies)

**Web Components & Attributes:**
- [MDN: Using data attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/How_to/Use_data_attributes)
- [MDN: Using Custom Elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements)
- [Web.dev: Custom Elements Best Practices](https://web.dev/articles/custom-elements-best-practices)
- [Open Web Components: Attributes and Properties](https://open-wc.org/guides/knowledge/attributes-and-properties/)
- [Smashing Magazine: Working With Shadow DOM](https://www.smashingmagazine.com/2025/07/web-components-working-with-shadow-dom/)
- [Ultimate Courses: Using Attributes in Custom Elements](https://ultimatecourses.com/blog/using-attributes-and-properties-in-custom-elements)

---
*Architecture research for: Strava Analytics Geographic Extension*
*Researched: 2026-02-14*
*Confidence: HIGH (verified with current documentation and API policies)*
